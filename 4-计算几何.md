# 计算几何

一大堆混东抄西抄的，不便于抄写(勉强能用)

```C++

#include <bits/stdc++.h>
#define debug(x) cout << #x << ": " << x << endl
using namespace std;
typedef long long ll;
const double eps=1e-6; //eps用于控制精度
const double pi=acos(-1.0);
const int maxn=1e5+7;
const int inf=0x3f3f3f3f;
const int mod=1e9+7;

int dcmp(double x)  //判断正负
{
    if(fabs(x)<eps) return 0;
    else if(x>0) return 1;
    return -1;
}

struct point  //点或向量
{
    double x,y;
    point(const point & p):x(p.x),y(p.y) {}
    point(double x=0,double y=0):x(x),y(y) {}
    bool operator == (const point & b) const{return dcmp(x-b.x)==0 && dcmp(y-b.y)==0;}
    void input() {scanf("%lf%lf",&x,&y);}
};

struct Line
{
    point s,e;
    double k;
    Line(point _s,point _e)
    {
        s=_s;e=_e;
        k=atan2(e.y-s.y,e.x-s.x);
    }
};

typedef point Vector;  //可能导致无法提交.

Vector operator + (Vector a,Vector b){return Vector(a.x+b.x,a.y+b.y);}
Vector operator - (Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}
Vector operator * (Vector a,double p){return Vector(a.x*p,a.y*p);}
Vector operator / (Vector a,double p){return Vector(a.x/p,a.y/p);}

double dot(Vector a,Vector b)  {return a.x*b.x+a.y*b.y;}
double length(Vector a)         {return sqrt(dot(a,a));}
double angle(Vector a,Vector b){return acos(dot(a,b)/length(a)/length(b));}
double cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}
Vector Rotate(Vector a,double rad) {return Vector(a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad));}
//以原点为起点  否则需要加起点坐标

//此处以 0,h/3旋转
pair<double,double> getpoint(const pair<double,double>&p,double rad)
{
    return make_pair(p.first*cos(rad)-(p.second-h/3)*sin(rad),p.first*sin(rad)+(p.second-h/3)*cos(rad)+h/3);
}

double dist(point a,point b) {return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}//两点距离
double area(point a,point b,point c) {return fabs(cross(b-a,c-a)/2);} //三角形面积

bool intersect(point a,point b,point c,point d) //判断线段AB与CD相交不考虑端点
{
    double t1=cross(c-a,d-a)*cross(c-b,d-b); //对于线段AB，ac叉乘ad和bc叉乘db是反向的
    double t2=cross(a-c,b-c)*cross(a-d,b-d); //同理对于CD
    return dcmp(t1)<0 && dcmp(t2)<0;
}
bool strictintersect(point a,point b,point c,point d)//AB与CD相交考虑端点，特判端点
{
    return
        dcmp(max(a.x,b.x)-min(c.x,d.x))>=0
        && dcmp(max(c.x,d.x)-min(a.x,b.x))>=0
        && dcmp(max(a.y,b.y)-min(c.y,d.y))>=0
        && dcmp(max(c.y,d.y)-min(a.y,b.y))>=0
        && dcmp(cross(c-a,d-a)*cross(c-b,d-b))<=0
        && dcmp(cross(a-c,b-c)*cross(a-d,b-d))<=0;
}
//点a到直线mn的距离
double distPtoline(point a,point m,point n) {return fabs(cross(a-m,a-n)/dist(m,n));}

//两条直线交点  直线用点加方向向量表示  cross在分母 需要先判断二者是否平行
point getlineintersection(point p,Vector v,point q,Vector w)
{
    Vector u=p-q;
    double t=cross(w,u)/cross(v,w);
    return p+v*t;
}
//求线段交点 先当成直线，再判断是否在线段上

//点和多边形位置关系
point p[maxn]; //凸多边形以点表示 为2pi表示在内部，pi表示在边上
int n;
bool inpolygon(point a)
{
    double alpha=0;
    for(int i=0;i<n;++i)
        alpha+=fabs(angle(p[i]-a,p[(i+1)%n]-a));
    return dcmp(alpha-2*pi)==0;
}

double polygonarea(vector<point>p)  //可以传个vector过来，vector里保存着所要求的点
{
    double sum=0;
    point O=point(0,0);  //O可任取，由于叉积有正有负，取在多边形外都可以
    for(int i=0;i<p.size();++i)
        sum+=cross(p[i]-O,p[(i+1)%n]-O);
    if(sum<0) sum=-sum;
    return sum/2;
}

//凸包
bool cmp1(point a,point b)
{
    if(fabs(a.x-b.x)<eps) return a.y<b.y;
    return a.x<b.x;
}

int ConvexHull(point *p,int n,point *ch)
{   //构造凸包
    sort(p,p+n,cmp1);
    int m=0;
    for(int i=0;i<n;i++)
    {
        while(m>1&&dcmp(cross(ch[m-1]-ch[m-2],p[i]-ch[m-2]))<=0)m--;
        ch[m++]=p[i];
    }
    int k=m;
    for(int i=n-2;i>=0;i--)
    {
        while(m>k&&dcmp(cross(ch[m-1]-ch[m-2],p[i]-ch[m-2]))<=0)m--;
        ch[m++]=p[i];
    }
    if(n>1)m--;
    return m;
}

/*
* 求凸包，Graham算法
* 点的编号0~n-1
* 返回凸包结果Stack[0~top-1]为凸包的编号
*/
const int MAXN = 305;
point p[MAXN];
int Stack[MAXN],top;
//相对于list[0]的极角排序
bool _cmp(point p1,point p2)
{
    double tmp = cross( (p1-p[0]),(p2-p[0]));
    if(dcmp(tmp) > 0)return true;
    else if(dcmp(tmp) == 0 && dcmp(dist(p1,p[0]) - dist(p2,p[0])) <= 0)
        return true;
    else return false;
}
void Graham(int n)
{
    point p0;
    int k = 0;
    p0 = p[0];
//找最下边的一个点
    for(int i = 1; i < n; i++)
    {
        if( (p0.y > p[i].y) || (p0.y == p[i].y && p0.x > p[i].x) )
        {
            p0 = p[i];
            k = i;
        }
    }
    swap(p[k],p[0]);
    sort(p+1,p+n,_cmp);
    if(n == 1)
    {
        top = 1;
        Stack[0] = 0;
        return;
    }
    if(n == 2)
    {
        top = 2;
        Stack[0] = 0;
        Stack[1] = 1;
        return ;
    }
    Stack[0] = 0;
    Stack[1] = 1;
    top = 2;
    for(int i = 2; i < n; i++)
    {
        while(top > 1 && dcmp( cross(p[Stack[top-1]]-p[Stack[top-2]],p[i]-p[Stack[top-2]] ) ) <=0)
            top--;
        Stack[top++] = i;
    }
}

//旋转卡壳
double rotatecalipers(point *ch,int n)//求直径 此处length表示长度的平方
{
    double res=-INF;
    ch[n]=ch[0];
    int q=1;
    for(int i=0;i<n;++i)
    {
        while(dcmp(cross(ch[q+1]-ch[i+1],ch[i]-ch[i+1])-cross(ch[q]-ch[i+1],ch[i]-ch[i+1]))>0)
        {
            q=(q+1)%n;
        }
        res=max(res,max(length(ch[q]-ch[i]),length(ch[q+1]-ch[i+1])));
    }
    return res;
}


double X,Y;
void solve(point a, point b, point c) //三点共圆圆心公式  已知三点求圆心
{
    double fm1=2 * (a.y - c.y) * (a.x - b.x) - 2 * (a.y - b.y) * (a.x - c.x);
    double fm2=2 * (a.y - b.y) * (a.x - c.x) - 2 * (a.y - c.y) * (a.x - b.x);
    if (fm1 == 0 || fm2 == 0)
    {
        X = Y = 1e18;
        return;
    }
    double fz1=a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y;
    double fz2=a.x * a.x - c.x * c.x + a.y * a.y - c.y * c.y;
    X = (fz1 * (a.y - c.y) - fz2 * (a.y - b.y)) / fm1;
    Y = (fz1 * (a.x - c.x) - fz2 * (a.x - b.x)) / fm2;
}

bool onSegment(point Pi , point Pj , point Q)
{
    if((Q.x - Pi.x) * (Pj.y - Pi.y) == (Pj.x - Pi.x) * (Q.y - Pi.y)  //叉乘
       //保证Q点坐标在pi,pj之间
       && min(Pi.x , Pj.x) <= Q.x && Q.x <= max(Pi.x , Pj.x)
       && min(Pi.y , Pj.y) <= Q.y && Q.y <= max(Pi.y , Pj.y))
        return true;
    else return false;
}



```

