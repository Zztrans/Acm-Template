# 动态规划

动态规划居然也有模板！(bksw

## 经典问题

### 整数划分dp

```C++
ll dp[maxn][maxn];///将i划分为最大数不超过j的方案数
	for(int i=1;i<maxn;++i)
    {
        for(int j=1;j<maxn;++j)
        {
            if(i==1 || j==1) dp[i][j]=1;
            else if(i==j) dp[i][j]=(1ll+dp[i][j-1]);
            else if(i<j) dp[i][j]=dp[i][i];
            else if(i>j) dp[i][j]=(dp[i-j][j]+dp[i][j-1]);///划分中有j 划分中没j
        }
    }
```

### 背包

```C++
int f[maxn];
void ZeroOnePack(int cost,int weight)//0-1背包
{
    for(int j=V;j>=cost;j--) f[j]=max(f[j],f[j-cost]+weight);
}
void CompletePack(int cost ,int weight)//完全背包
{
    for(int j=cost;j<=V;j++) f[j]=max(f[j],f[j-cost]+weight);
}
void MultiPack(int cost,int weight,int amount)//多重背包
{
    if(cost*amount>=V)
    {
        CompletePack(cost,weight);
        return;
    }
    int k=1;
    while(k<amount)
    {
        ZeroOnePack(k*cost,k*weight);
        amount-=k;
        k*=2;
    }
    ZeroOnePack(amount*cost,amount*weight);
}
```

### LIS

```C++
int a[maxn],b[maxn];
//对于排列的题目,1~n需要考虑清楚究竟是最长上升子序列 还是最长连续序列
    int cnt=0;
    for(int i=1;i<=n;++i)
    {
        int pos=upper_bound(b+1,b+1+cnt,a[i])-b;
        b[pos]=a[i];
        if(pos>cnt) cnt=pos;
    }
```

- 若LCS要求nlog，可以考虑转化为LISdp

## 单调队列优化dp

```
    for(int i=1;i<=n;++i)
    {
        while(l<=r && a[q[r]]<=a[i]) r--;
        q[++r]=i;
        while(l<=r && q[l]<=i-k) l++;
        if(i>=k) ma[i]=a[q[l]];
    }
```

- 首先要把式子写成单调队列的形式，然后维护(等于没说)。

- 维护可能不是一个值，一个结构体也行，有优先顺序即可。

- 牛逼的还可以结合线段树(

  二维滑动窗口求子矩阵最大值

```C++
int n,m,k;
int mx[maxn][maxn],a[maxn][maxn];
int val[maxn],pos[maxn];
void solve_row()
{
    for(int i=1;i<=n;++i)
    {
        int l=1,r=1;
        for(int j=1;j<=m;++j)
        {
            while(l<r && val[r-1]<=a[i][j]) r--;
            val[r]=a[i][j];pos[r]=j;r++;
            if(pos[l]==j-k) l++;
            if(j>=k) mx[i][j]=val[l];
        }
    }
}
void solve_col()
{
    ll ans=0;
    for(int i=k;i<=m;++i)
    {
        int l=1,r=1;
        for(int j=1;j<=n;++j)
        {
            while(l<r && val[r-1]<=mx[j][i]) r--;
            val[r]=mx[j][i];pos[r]=j;r++;
            if(pos[l]==j-k) l++;
            if(j>=k) ans+=val[l];
        }
    }
    printf("%lld\n",ans);
}
```

## 数位dp

例题：找a，b范围内数对，使得$x\oplus y<w$，$abs(x-y)$不超过m。

做法：小于好维护，绝对值差值要维护继承到下一位(

```
ll dp[33][3][3][2][2][2];

ll dfs(int pos,int sta1,int sta2,bool lima,bool limb,bool eq)
{
    sta1=min(sta1,1),sta2=min(sta2,1);
    if(pos<0) return sta1>=0 && sta2>=0;
    if(sta1<-1 || sta2<-1) return 0;
    if(dp[pos][sta1+1][sta2+1][lima][limb][eq]!=-1) return dp[pos][sta1+1][sta2+1][lima][limb][eq];
    ll res=0;
    int up1=lima?na[pos]:1,up2=limb?nb[pos]:1;
    for(int i=0;i<=up1;++i)
    {
        for(int j=0;j<=up2;++j)
        {
            if(eq && (i^j)>nn[pos]) continue;
            int st1=sta1*2+nm[pos]-i+j;
            int st2=sta2*2+nm[pos]+i-j;
            res+=dfs(pos-1,st1,st2,lima&&(i==up1),limb&&(j==up2),(eq&&((i^j)==nn[pos])));
        }
    }
    return dp[pos][sta1+1][sta2+1][lima][limb][eq]=res;
}
```

- 套路太多，有可能对单个数，有可能是数对
- 框架大致如上，注意维护合法性即可
- 小技巧，限制条件一样的话，多组不计lim，否则必须重新换，重新dp

