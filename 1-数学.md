# 数学 or 数论

## 线性筛

赠送phi和mu

```c++
const int maxn=1e7+10;
bool notprime[maxn];
int prime[maxn/10];
int mu[maxn],phi[maxn];
int cnt;
void getprime()
{
    notprime[0]=notprime[1]=1;
    phi[1]=mu[1]=1;
    cnt=0;
    for(int i=2;i<maxn;++i)
    {
        if(!notprime[i]) 
        {
            prime[cnt++]=i;
            phi[i]=i-1;
            mu[i]=-1;
        }
        for(int j=0;j<cnt && 1ll*i*prime[j]<maxn;++j)
        {
            notprime[i*prime[j]]=1;
            if(i%prime[j]==0) 
            {
                phi[i*prime[j]]=phi[i]*prime[j];
				mu[i*prime[j]]=0;
                break;
            }
            phi[i*prime[j]] = phi[i]*(prime[j]-1);
            mu[i*prime[j]]=-smu[i];
        }
    }
    for(int i=2;i<maxn;++i)
    {
        mu[i]+=mu[i-1];
        phi[i]+=phi[i-1];
    }
}
```

基础可筛的 

素因数个数      $vis[i*prime[j]]=vis[i]+1$

约数个数  $d[i]$:约数个数. $num[i]$:i的最小质因数个数

```C++
			if(i%prime[j]==0)
			{
				d[i*prime[j]]=d[i]/(num[i]+1)*(num[i]+2);
				num[i*prime[j]]=num[i]+1;
				break;
			}
			else
			{
				d[i*prime[j]]=d[i]*2;
				num[i*prime[j]]=1;
			}
```



## 区间筛

```C++
///区间筛
const int maxn = 1e6 + 5;
bool is_prime[maxn], is_prime_small[maxn];
ll prime[maxn];
ll prime_num = 0;

//对区间[a, b)的整数执行筛法，is_prime[i - a] = true <=> i 是素数
void segment_sieve(ll a, ll b) {
    for(int i = 0; (ll)i * i < b; i ++)  is_prime_small[i] = true;//对[2, sqrt(b)]进行初始化
    for(int i = 0; i < b - a; i ++)  is_prime[i] = true;
    for(int i = 2; (ll)i * i < b; i ++) {
        if(is_prime_small[i]) {
            for(ll j = 2 * i; (ll)j * j < b; j += i)    is_prime_small[j] = false;//筛[2, sqrt(b))
            for(ll j = max(2LL, (a + i - 1) / i) * i; j < b; j += i)    is_prime[j - a] = false;//筛[a,b)
        }
    }
    for(ll i = 0; i < b - a; i ++)
        if(is_prime[i]) prime[prime_num ++] = i + a;
}

```



## ex_crt和ex_gcd

```C++
void ex_gcd(ll a, ll b, ll &d, ll &x, ll &y) {
    if (!b)
    {
        d = a, x = 1, y = 0;
    }
    else
    {
        ex_gcd(b, a % b, d, y, x);
        y -= x * (a / b);
    }
}
//一堆理解
        //ax+by==c  d= g c d ; ax = c (mod b)  //x的最小整数解 一个特解
        //  可根据特解x得到 y=(c-a*x)/b;  后续可推出通解
/*     求y的最小正整数解 ax+by=c;  一对解x y
g=gcd
    ll t=a/g;
    y=y%t+t;
    x=(g-y*b)/a;
    assert(a*x+y*b==g);
    x*=c/g;
    y*=c/g;

    x的版本反过来..
                        */
        if(c%d) printf("FOREVER\n");
        else
        {
            a/=d;
            b/=d;
            c/=d;
            printf("%lld\n",(x%b*c%b+b)%b);
        }

///ax%b落在l~r区间最小的x
ll calc(int l, int r, int a, int b)
{
    if (l>r || l==0) return 0;
    if (a>=b) a%=b;
    if (a==0) return -1;
    if ((l+a-1)/a<=r/a) return (l+a-1)/a; ///case 2
    ll y = calc((-r % a + a) % a, (-l % a + a) % a, b, a);
    if (y==-1) return -1;
    return (((1ll * b * y + l) + (a - 1)) / a);
}

        scanf("%d %d %d %d %d", &a, &b, &s, &l, &r);
        l = ((l - s) % b + b) % b;
        r = ((r - s) % b + b) % b;
        cout << calc(l, r, a, b) << '\n';///步长a 环长b

//中国剩余定理板子  ,模数数组1~n,余数数组1~n;
ll ex_crt(ll *m, ll *r, int n)
{
    ll M = m[1], R = r[1], x, y, d;
    for (int i = 2; i <= n; ++i)
    {
        ex_gcd(M, m[i], d, x, y);
        if ((r[i] - R) % d)
            return -1;
        x = (r[i] - R) / d * x % (m[i] / d);
        R += x * M;
        M = M / d * m[i];
        R %= M;
    }
    return R > 0 ? R : R + M;
}
```

## BSGS

```C++
//求a^x mod p = b  其中 (y,p)=1的最小的x O（sqrt(p)） 使用map多log
ll BSGS(ll a,ll b,ll p)
{
    if(!a) return b?-1:1;
    if(b==1) return 0;
    map<ll,ll>mp;
    ll m=ceil(sqrt(p)),ax=1;
    for(int i=0; i<m; i++)
    {
        mp[ax]=i;
        ax=ax*a%p;
    }
    ll am=quick(a,m),aj=am*quick(b,p-2)%p;
    for(int i=1;i<=m; i++)
    {
        if(mp.count(aj)) return m*i-mp[aj];
        aj=aj*am%p;
    }
    return -1;
}
```

ex_bsgs  hash相当于map

```C++
void ex_BSGS(int y,int z,int p)
{
	if(z==1) {puts("0");return;}
	int k=0,a=1;
	while(233)
	{
		int d=__gcd(y,p);if(d==1)break;
		if(z%d){NoAnswer();return;}
		z/=d;p/=d;++k;a=1ll*a*y/d%p;
		if(z==a){printf("%d\n",k);return;}
	}
	Hash.clear();
	int m=sqrt(p)+1;
	for(int i=0,t=z;i<m;++i,t=1ll*t*y%p)Hash.Insert(t,i);
	for(int i=1,tt=fpow(y,m,p),t=1ll*a*tt%p;i<=m;++i,t=1ll*t*tt%p)
	{
		int B=Hash.Query(t);if(B==-1)continue;
		printf("%d\n",i*m-B+k);return;
	}
	NoAnswer();
}
```

## 原根

```C++
const int maxn=1e6+7;
int phi[maxn],prime[maxn],rt[maxn],fc[maxn],c1,c2,cans,ans[maxn];
bool notprime[maxn];
int n;
void getphi()
{
    c1=0;
    phi[1]=1;
    for(int i=2;i<maxn;++i)
    {
        if(!notprime[i])
        {
            prime[c1++]=i;
            phi[i]=i-1;
        }
        for(int j=0;j<c1&&1ll*prime[j]*i<maxn;++j)
        {
            notprime[i*prime[j]]=1;
            if(i%prime[j]==0)
            {
                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }
            phi[i*prime[j]]=phi[i]*(prime[j]-1);
        }
    }//2,4,p^e,2p^e,存在性
    rt[2]=rt[4]=1;
    for(int i=1;i<c1;++i)
    {
        for(int j=1;(1ll*j*prime[i])<maxn;j*=prime[i]) rt[j*prime[i]]=1;
        for(int j=2;(1ll*j*prime[i])<maxn;j*=prime[i]) rt[j*prime[i]]=1;
    }
}
int quick(int a,int b,int p)
{
    int res=1;
    while(b)
    {
        if(b&1) res=(1ll*res*a)%p;
        a=(1ll*a*a)%p;
        b>>=1;
    }
    return res;
}
void getfac(int p)
{
    c2=0;
    for(int i=2;i*i<=p;++i)
        if(p%i==0)
        {
            fc[c2++]=i;
            while(p%i==0) p/=i;
        }
    if(p>1) fc[c2++]=p;
}
bool check(int x,int p)
{
    if(quick(x,phi[p],p)!=1) return 0; //确保阶的倍数
    for(int i=0;i<c2;++i)
        if(quick(x,phi[p]/fc[i],p)==1) return 0; //确保最小,质因数不存在能为1
    return 1;
}
int findrt(int p) //第一个原根
{
    for(int i=1;i<p;++i)
        if(check(i,p)) return i;
    return 0;
}
void getrt(int p,int x)
{
    cans=0;
    int cur=1;
    for(int i=1;i<=phi[p];++i)
    {
        cur=(1ll*cur*x)%p;
        if(__gcd(i,phi[p])==1) ans[cans++]=cur;
    }
}
int main()
{
    getphi();
    int t;
    cin>>t;
    while(t--)
    {
        int d;
        cin>>n>>d;
        if(rt[n])
        {
            getfac(phi[n]);
            int fi=findrt(n);
            getrt(n,fi);
            sort(ans,ans+cans);
            cout<<cans<<'\n';
            for(int i=0;i<cans/d;++i) cout<<ans[(i+1)*d-1]<<' ';
            cout<<'\n';
        }
        else cout<<0<<'\n'<<'\n';
    }
    return 0;
}
```



## 组合数学

```C++
ll quick(ll x,ll n)
{
    ll res=1;
    while(n)
    {
        if(n&1) res=(res*x)%mod;
        x=x*x%mod;
        n>>=1;
    }
    return res;
}
ll inv(ll x) {return quick(x,mod-2);}
ll fac[maxn],invfac[maxn];
void init()
{
    fac[0]=1;
    for(int i=1;i<maxn;++i) fac[i]=(fac[i-1]*i)%mod;
    invfac[maxn-1]=inv(fac[maxn-1]);
    for(int i=maxn-2;i>=0;--i) invfac[i]=(invfac[i+1]*(i+1))%mod;
}
ll C(int n,int m)
{
    if(n<m || m<0) return 0;
    return fac[n]*invfac[m]%mod*invfac[n-m]%mod;
}
//C还可以记忆化搜索 
//杨辉三角初始化递推计算

ll Catalan(int n)
{
    return C(2*n,n)*inv(n+1)%mod;
}

const int maxn=1e2+7,mod=20090126;
ll stirling2[maxn][maxn],fac[maxn];
ll stirling1[maxn][maxn];
void init()
{
    fac[0]=1;
    for(int i=1;i<maxn;++i) fac[i]=fac[i-1]*i%mod;
    for(int i=1;i<maxn;++i)  ///将n个不同元素构成m个圆排列的数目
    {
        stirling1[i][0]=0,stirling1[i][i]=1;
        for(int j=1;j<i;++j) stirling1[i][j]=(stirling1[i-1][j-1]+(i-1)*stirling1[i-1][j]%mod)%mod;
    }
    for(int i=1;i<maxn;++i)  ///将n个不同元素划分为m个无区别集合  有区别则分别乘j的排列
    {
        stirling2[i][1]=stirling2[i][i]=1;
        for(int j=2;j<i;++j) stirling2[i][j]=(stirling2[i-1][j-1]+j*stirling2[i-1][j]%mod)%mod;
    }
}


ll Inv[maxn];
void inverse()
{
    Inv[1]=1;
    for(int i=2;i<maxn;++i) Inv[i] = (ll)(mod-mod/i)*Inv[mod%i]%mod;
}
```

### lucas定理

```C++
//4.Lucas定理计算 大组合数取模
//需要计算C[100000000009][500005] mod为素数且mod不是很大 1e5
const int maxn=1e6+10;
ll fac[maxn];
ll p;
void init()
{
    fac[0]=1;
    for(int i=1; i<=p; i++) a[i]=(a[i-1]*i)%p;
}

ll quick(ll x,ll n)
    
ll C(ll n,ll m)
{
    if(m>n)return 0;
    return (fac[n]*quick(fac[m],p-2))%p*quick(fac[n-m],p-2)%p;
}

ll Lucas(ll n,ll m)
{
    if(!m) return 1;
    return C(n%p,m%p)*Lucas(n/p,m/p)%p;
}
```

### polya

需要根据题目考虑，以下仅供参考

```C++
ll Polya(ll n,ll m) //仅m==3
{
    ll ans=0;
    for(int i=0;i<m;++i)
    {
        ans+=quick(n,__gcd(i*2,m*2));
    }
    if(m&1)
    {
        ans+=3*quick(n,4);
    }
    ans/=6;
    return ans;
}

ll polya(int n)  ///n很大 仅旋转同构
{
    ll ans=0;
    for(int i=1;1ll*i*i<=n;++i)
    {
        if(n%i==0)
        {
            ans=(ans+(1ll*Phi(n/i)%mod*quick(n,i-1))%mod)%mod; ///枚举约数 分母放在里面
            if(i*i!=n) ans=(ans+(1ll*Phi(i)%mod*quick(n,n/i-1))%mod)%mod;
        }
    }
    return ans;
}
```



## 多项式

### 函数卷积

```c++

ll n,k;
void mul(ll a[],ll b[])
{
    memset(s,0,sizeof(s));
    for(int i=1;i*i<=n;++i)
    {
        s[i*i]=(s[i*i]+a[i]*b[i]%mod)%mod;
        for(int j=i+1;i*j<=n;++j) s[i*j]=(s[i*j]+a[i]*b[j]%mod+a[j]*b[i]%mod)%mod;
    }
    for(int i=1;i<=n;++i) a[i]=s[i];
}
void power(ll a[],ll p)
{
    memset(ans,0,sizeof(ans));
    ans[1]=1;
    while(p)
    {
        if(p&1) mul(ans,a);
        mul(a,a);
        p>>=1;
    }
    for(int i=1;i<=n;++i) a[i]=ans[i];
}
int main()
{
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;++i) scanf("%lld",&f[i]);
    power(f,inv(k));
    for(int i=1;i<=n;++i) printf("%lld%c",f[i],(i==n?'\n':' '));
    return 0;
}
```

### 拉格朗日插值

```C++
/*
ll f(int k)  //给点n个点 构造函数确定n-1次多项式 暴力O(n^2)拉格朗日插值求f(k);
{
    ll ans=0;
    for(int i=1;i<=n;++i)
    {
        ll s1=y[i]%mod,s2=1;  //分子 分母
        for(int j=1;j<=n;++j)
            if(i!=j) s1=s1*(k-x[j])%mod,s2=s2*((x[i]-x[j]%mod+mod)%mod)%mod;
        ans+=s1*inv(s2)%mod;
        ans=(ans+mod)%mod;
    }
    return ans;
}
*/

ll pre[maxn],suf[maxn],fac[maxn];
ll f(int k)//此处求前缀和i^k,实际上是k+1次多项式,不给定点值,选取连续的点,优化O(k log) 还可线性处理逆元
{
    pre[0]=suf[k+3]=fac[0]=1;
    for(int i=1;i<=k+2;++i) pre[i]=1ll*pre[i-1]*(n-i)%mod;
    for(int i=k+2;i>=1;--i) suf[i]=1ll*suf[i+1]*(n-i)%mod;
    for(int i=1;i<=k+2;++i) fac[i]=1ll*fac[i-1]*i%mod;
    ll ans=0;
    ll y=0;
    for(int i=1;i<=k+2;++i)     //k+1次多项式,需要k+2个点插值
    {
        y=(y+quick(i,k))%mod;   //注意此处的yi是k+1次多项式,yi指的是前缀和,而不是原函数
        ll a=pre[i-1]*suf[i+1]%mod;
        ll b=fac[i-1]*((k+2-i)&1?-1ll:1ll)*fac[k+2-i]%mod; //分母fac注意奇偶性
        ans=(ans+y*a%mod*inv(b)%mod)%mod;
    }
    return (ans+mod)%mod;
}
```

### FFT NTT

```C++
const double pi=acos(-1.0);
const int maxn=2e6+7;

struct Complex
{
    double x,y;
    Complex(double _x=0.0,double _y=0.0) :x(_x),y(_y) {}
    Complex operator - (const Complex &b) const {return Complex(x-b.x,y-b.y);}
    Complex operator + (const Complex &b) const {return Complex(x+b.x,y+b.y);}
    Complex operator * (const Complex &b) const {return Complex(x*b.x-y*b.y,x*b.y+y*b.x);}
};

void change(Complex *y,int len)
{
    for(int i=1,j=len/2;i<len-1;i++)
    {
        if(i<j) swap(y[i],y[j]);
        //交换互为小标反转的元素,i<j保证交换依次
        //i做正常+1,j反转类型的+1,始终保持i和j是反转的
        int k=len/2;
        while(j>=k)
        {
            j-=k;
            k/=2;
        }
        if(j<k) j+=k;
    }
}
//做FFT  on==1时DFT on==-1时IDFT
void fft(Complex *y,int len,int on)
{
    change(y,len);
    for(int h=2;h<=len;h<<=1)
    {
        Complex wn(cos(-on*2*pi/h),sin(-on*2*pi/h));
        for(int j=0;j<len;j+=h)
        {
            Complex w(1,0);
            for(int k=j;k<j+h/2;k++)
            {
                Complex u=y[k];
                Complex t=w*y[k+h/2];
                y[k]=u+t;
                y[k+h/2]=u-t;
                w=w*wn;
            }
        }
    }
    if(on==-1) for(int i=0;i<len;++i) y[i].x/=len;
}

///ntt带乘法 求逆 多项式除法余数
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int GG=3,mod=998244353,N=1e6+7;
ll quick(ll a,ll b)
{
	ll res=1;
	while(b)
    {
        if(b&1) res=res*a%mod;
        a=a*a%mod;
        b>>=1;
    }
	return res;
}
int rev[N];
ll GG_inv, len_inv;
void ntt(ll *a, int len, int o)
{
	len_inv = quick(len, mod - 2);
	for(int i = 0; i <= len; i ++) rev[i] = (rev[i >> 1] >> 1) | ((i&1) * len >> 1);
	for(int i = 0; i <= len; i ++) if(i < rev[i]) swap(a[i], a[rev[i]]);
	for(int i = 2; i <= len; i <<= 1){
		ll wn = quick((o == 1)? GG:GG_inv, (mod - 1) / i);
		for(int j = 0, p = i / 2; j + i - 1<= len; j += i){
			ll w0 = 1;
			for(int k = j; k < j + p; k ++, w0 = w0 * wn % mod){
				ll X = a[k], Y = w0 * a[k + p] % mod;
				a[k] = (X + Y) % mod;
				a[k + p] = (X - Y + mod) % mod;
			}
		}
	}
	if(o == -1) for(int i = 0; i <= len; i ++) a[i] = a[i] * len_inv % mod;
}
ll c[N];

void inv(ll *a, ll *b, int sz)///多项式求逆板子 a*a^-1=1
{
	if(sz == 0) {b[0] = quick(a[0], mod - 2); return;}
	inv(a, b, sz / 2);
	int len = 1;
	for(; len <= sz + sz; len <<= 1);
	for(int i = 0; i <= sz; i ++) c[i] = a[i];
	for(int i = sz + 1; i <= len; i ++) c[i] = 0;
	ntt(c, len, 1), ntt(b, len, 1);
	for(int i = 0; i <= len; i ++) b[i] = (b[i] * 2 % mod - b[i] * b[i] % mod * c[i] % mod + mod) % mod;
	ntt(b, len, -1);
	for(int i = sz + 1; i <= len; i ++) b[i] = 0;
}
void mul(ll *a, ll *b, int n, int m)///多项式乘法板子 a*b
{
	int len = 1;
	for(; len <= n + m; len <<= 1);
	ntt(a, len, 1), ntt(b, len, 1);
	for(int i = 0; i <= len; i ++) a[i] = a[i] * b[i] % mod;
	ntt(a, len, -1);
}
ll a[N], b[N], F[N], G[N], Q[N], GR[N], FR[N], GR_inv[N], R[N];
int n, m;

int main()
{
	GG_inv = quick(GG, mod - 2);
	scanf("%lld%lld", &n, &m);
	for(int i = 0; i <= n; i ++) scanf("%lld", &F[i]), FR[n - i] = F[i];
	for(int i = 0; i <= m; i ++) scanf("%lld", &G[i]), GR[m - i] = G[i];
	for(int i = n - m + 1; i <= m; i ++) GR[i] = 0;// mod n - m + 1, 即把后面的全部清0
	inv(GR, GR_inv, n - m);//注意长度是 n - m, 要补齐
	mul(FR, GR_inv, n, n - m);	//长度要补齐
	for(int i = 0; i <= n - m; i ++) Q[i] = FR[n - m - i];//翻转
	for(int i = 0; i <=  n - m; i ++) printf("%lld ", Q[i]); printf("\n");//输出
	mul(G, Q, m, n - m);//直接算余数R
	for(int i = 0; i < m; i ++) R[i] = (F[i] - G[i] + mod) % mod;
	for(int i = 0; i <  m; i ++) printf("%lld ", R[i]); printf("\n");
	return 0;
}

```

ntt模数 P=1004535809  g=3

构造卷积关系。固定差值对应的乘积，考虑反转另一个数组，得到卷积。

解决字符串匹配问题

### FWT

```C++
const int N=1<<18;//数最大
/// O(n*2^(n))
//模意义下
void fwt_or(int *a,int opt)
{
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k)
                if(opt==1)a[i+j+k]=(a[j+k]+a[i+j+k])%mod;
                else a[i+j+k]=(a[i+j+k]+mod-a[j+k])%mod;
}
void fwt_and(int *a,int opt)
{
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k)
                if(opt==1)a[j+k]=(a[j+k]+a[i+j+k])%mod;
                else a[j+k]=(a[j+k]+mod-a[i+j+k])%mod;
}
//inv2为2的逆元  inv2=mod/2+1;
void fwt_xor(int *a,int opt)
{
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k)
            {
                int X=a[j+k],Y=a[i+j+k];
                a[j+k]=(X+Y)%mod;a[i+j+k]=(X+mod-Y)%mod;
                if(opt==-1)a[j+k]=1ll*a[j+k]*inv2%mod,a[i+j+k]=1ll*a[i+j+k]*inv2%mod;
            }
}

//or卷积
void fwt(ll *P,int opt)
{
	for(int i=2;i<=N;i<<=1)
		for(int p=i>>1,j=0;j<N;j+=i)
			for(int k=j;k<j+p;++k)
				P[k+p]+=P[k]*opt;
}
//and卷积
void fwt(ll *P,int opt)
{
	for(int i=2;i<=N;i<<=1)
		for(int p=i>>1,j=0;j<N;j+=i)
			for(int k=j;k<j+p;++k)
				P[k]+=P[k+p]*opt;
}
//异或卷积
void fwt(ll *P,int opt)
{
	for(int i=2;i<=N;i<<=1)
		for(int p=i>>1,j=0;j<N;j+=i)
			for(int k=j;k<j+p;++k)
			{
				ll x=P[k],y=P[k+p];
				P[k]=(x+y);P[k+p]=x-y;
				if(opt==-1) P[k]=P[k]/2,P[k+p]=P[k+p]/2;
			}
}

```

## 矩阵

### 矩阵快速幂

```C++
const int v=2; //开维数
int d;//实际维数
struct matrix
{
    ll m[v][v];
    void init() {memset(m,0,sizeof(m));for(int i=0;i<d;++i) m[i][i]=1;}
    void clear() {memset(m,0,sizeof(m));}
    matrix operator +(const matrix &o) const
    {
        matrix res={};
        for(int i=0;i<d;++i)
            for(int j=0;j<d;++j)
                res.m[i][j]=(m[i][j]+o.m[i][j])%mod;
        return res;
    }
    matrix operator *(const matrix &o) const
    {
        matrix res={};
        for(int i=0; i<d; i++)
            for(int j=0; j<d; j++)
                for(int k=0; k<d; k++)
                    res.m[i][j]=(res.m[i][j]+m[i][k]*o.m[k][j]%mod)%mod;
        return res;
    }
    matrix operator -(const matrix &o) const
    {
        matrix res={};
        for(int i=0;i<d;++i)
            for(int j=0;j<d;++j)
                res.m[i][j]=(m[i][j]-o.m[i][j]+mod)%mod;
        return res;
    }
}Ans, base;
inline void mat_quick(ll p)
{
    Ans.init();
    base={1,1,1,0};
    while(p)
    {
        if(p & 1) Ans = Ans*base;
        base = base*base;
        p >>= 1;
    }
}
```

### 高斯消元求解线性方程组

```c++
const double eps=1e-8;
double a[maxn][maxn];
int n;
void gauss()
{
    for(int j=1;j<=n;++j)                  //枚举列 其实也是行
    {
        int mx=j;
        for(int i=j+1;i<=n;++i)            //最大系数
            if(fabs(a[i][j])>fabs(a[mx][j])) mx=i;
        if(mx!=j) for(int k=1;k<=n+1;++k) swap(a[j][k],a[mx][k]);
        if(fabs(a[j][j])<eps)
        {
            puts("No Solution");   //全为1 自由元
            return;
        }
        for(int i=1;i<=n;++i)              //每一行进行消元
        {
            if(i!=j)
            {
                double tmp=a[i][j]/a[j][j];
                for(int k=j+1;k<=n+1;++k)  //前面全消掉了为0
                    a[i][k]-=a[j][k]*tmp;
            }
        }
    }
    //上述操作结束后，矩阵会变成这样
    /*
    k1*a=e1
    k2*b=e2
    k3*c=e3
    k4*d=e4
    */
    for(int i=1;i<=n;++i) printf("%.2f\n",a[i][n+1]/a[i][i]);
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n+1;++j)
            scanf("%lf",&a[i][j]);
    gauss();
    return 0;
}
```

### 基尔霍夫矩阵(矩阵行列式求值)

生成树计数

```C++
ll exgcd(ll a,ll b,ll &x,ll &y)//乘法逆元返回的d是a,b的公约数，x是a mod b的逆元
{
    if(b==0)
    {
        x=1;y=0;
        return a;
    }
    ll d=exgcd(b,a%b,x,y);
    ll t=x;
    x=y;
    y=t-a/b*y;
    return d;
}
//单个图去掉id即可
ll det(int id,int n)
{
    ll ans=1;
    int flag=1;
    int i,j,k;
    for(i=1;i<=n;i++)
    {
        if(a[id][i][i]==0)
        {
            for(j=i+1;j<=n;j++)
            {
                if(a[id][j][i])break;
            }
            if(j>n)return 0;
            flag=!flag;
            for(k=i;k<=n;k++)
                swap(a[id][i][k],a[id][j][k]);
        }
        ans=ans*a[id][i][i]%mod;
        ll x,y;
        ll tep=exgcd(a[id][i][i],mod,x,y);
        for(k=i+1;k<=n;k++) a[id][i][k]=a[id][i][k]*x%mod;
        for(j=i+1;j<=n;j++)
        {
            for(k=i+1;k<=n;k++)
            {
                a[id][j][k]=(a[id][j][k]-a[id][j][i]*a[id][i][k])%mod;
                if(j==k)
                    a[id][j][k]=(a[id][j][k]+mod)%mod;
            }
        }
    }
    ans=(ans%mod+mod)%mod;
    if(flag)return ans;
    return mod-ans;
}
```

main:维护度数，求n-1阶矩阵的行列式即可

```C++
            a[0][v][u]--,a[0][u][v]--;
            du[0][u]++,du[0][v]++;
        for(int i=1;i<=n;i++) a[0][i][i]=du[0][i];
```

### 矩阵求逆

```C++
void gauss()
{
    for(int j=1;j<=n;++j)                  //枚举列 其实也是行
    {
        int mx=j;
        for(int i=j+1;i<=n;++i)            //最大系数
            if(abs(a[i][j])>abs(a[mx][j])) mx=i;
        if(mx!=j) swap(a[mx],a[j]);
        if(!a[j][j])
        {
            puts("No Solution");   //全为1 自由元
            return;
        }
        ll inv=quick(a[j][j],mod-2);
        for(int i=1;i<=n;++i)              //每一行进行消元
        {
            if(i!=j)
            {
                ll tmp=a[i][j]*inv%mod;
                for(int k=j;k<=n*2;++k)  //前面全消掉了为0
                {
                    a[i][k]-=a[j][k]*tmp;
                    a[i][k]=(a[i][k]%mod+mod)%mod;
                }
            }
        }
        for(int i=1;i<=2*n;++i)
            a[j][i]=a[j][i]*inv%mod;
    }
    for(int i=1;i<=n;++i)
        for(int j=n+1;j<=2*n;++j)
            printf("%lld%c",a[i][j],j==2*n?'\n':' ');
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            scanf("%lld",&a[i][j]);
    for(int i=1;i<=n;++i) a[i][i+n]=1;
    gauss();
    return 0;
}
```

### bitset优化解异或方程组

```C++
const int N=507;
int n,m,ans[N*N];
bitset<N*N>a[N*N];
void gauss()
{
    for(int j=1;j<=n*m;++j)
    {
        for(int i=j;i<=n*m;++i)    //找到一个系数为1的一行 交换
            if(a[i][j]>0)
            {
                swap(a[i],a[j]);
                break;
            }
        if(!a[j][j]) ans[j]=1;     //该列全为1  说明自由元 答案任意
        for(int i=j+1;i<=n*m;++i)  //消元
            if(a[i][j]) a[i]^=a[j];
    }
    for(int i=n*m;i>=1;--i)        //从尾部开始得到答案
        for(int j=i+1;j<=n*m;++j)
            ans[i]^=(ans[j]*a[i][j]);
}
```

## 杂项

---

### 线性基

前缀版本？

```C++
int d[maxn][31],pos[maxn][31];
void add(int p,int x)
{
    for(int i=0;i<=30;++i)
    {
        d[p][i]=d[p-1][i];
        pos[p][i]=pos[p-1][i];
    }
    int now=p;
    for(int i=30;i>=0;--i)
    {
        if(x&(1<<i))
        {
            if(!d[p][i])
            {
                d[p][i]=x;
                pos[p][i]=now;
                break;
            }
            else
            {
                if(now>pos[p][i])
                {
                    swap(now,pos[p][i]);
                    swap(x,d[p][i]);
                }
                x^=d[p][i];
            }
        }
    }
}

//线性基板子
ll d[66];
void add(ll x)
{
    for(int i=62;i>=0;--i)
    {
        if(x&(1ll<<i))
        {
            if(d[i]) x^=d[i];
            else
            {
                d[i]=x;
          		break;
            }
        }
    }
}
```







---

### 一些数论公式

- 当 $x\geq\phi(p)$ 时有 $a^x\equiv a^{x ; mod ; \phi(p) + \phi(p)}\pmod p$
- $\mu^2(n)=\sum_{d^2|n} \mu(d)$
- $\sum_{d|n} \varphi(d)=n$
- $\sum_{d|n} 2^{\omega(d)}=\sigma_0(n^2)$，其中 $\omega$ 是不同素因子个数
- $\sum_{d|n} \mu^2(d)=2^{\omega(d)}$

### 一些数论函数求和的例子

- $\sum_{i=1}^n i[gcd(i, n)=1] = \frac {n \varphi(n) + [n=1]}{2}$
- $\sum_{i=1}^n \sum_{j=1}^m [gcd(i,j)=x]=\sum_d \mu(d) \lfloor \frac n {dx} \rfloor \lfloor \frac m {dx} \rfloor$
- $\sum_{i=1}^n \sum_{j=1}^m gcd(i, j) = \sum_{i=1}^n \sum_{j=1}^m \sum_{d|gcd(i,j)} \varphi(d) = \sum_{d} \varphi(d) \lfloor \frac nd \rfloor \lfloor \frac md \rfloor$
- $S(n)=\sum_{i=1}^n \mu(i)=1-\sum_{i=1}^n \sum_{d|i,d < i}\mu(d) \overset{t=\frac id}{=} 1-\sum_{t=2}^nS(\lfloor \frac nt \rfloor)$
  - 利用 $[n=1] = \sum_{d|n} \mu(d)$
- $S(n)=\sum_{i=1}^n \varphi(i)=\sum_{i=1}^n i-\sum_{i=1}^n \sum_{d|i,d<i} \varphi(i)\overset{t=\frac id}{=} \frac {i(i+1)}{2} - \sum_{t=2}^n S(\frac n t)$
  - 利用 $n = \sum_{d|n} \varphi(d)$
- $\sum_{i=1}^n \mu^2(i) = \sum_{i=1}^n \sum_{d^2|n} \mu(d)=\sum_{d=1}^{\lfloor \sqrt n \rfloor}\mu(d) \lfloor \frac n {d^2} \rfloor$
- $\sum_{i=1}^n \sum_{j=1}^n gcd^2(i, j)= \sum_{d} d^2 \sum_{t} \mu(t) \lfloor \frac n{dt} \rfloor ^2 \ \overset{x=dt}{=} \sum_{x} \lfloor \frac nx \rfloor ^ 2 \sum_{d|x} d^2 \mu(\frac xd)$
- $\sum_{i=1}^n \varphi(i)=\frac 12 \sum_{i=1}^n \sum_{j=1}^n [i \perp j] - 1=\frac 12 \sum_{i=1}^n \mu(i) \cdot\lfloor \frac n i \rfloor ^2-1$

