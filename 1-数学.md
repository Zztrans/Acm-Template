# 数学 or 数论

## 素数

### 线性筛

```c++
bool notprime[maxn];
int prime[maxn],cnt;
int mu[maxn],phi[maxn];
void getprime() {
    notprime[0]=notprime[1]=1;phi[1]=mu[1]=1;
    cnt=0;
    for(int i=2;i<maxn;++i) {
        if(!notprime[i]) {
            prime[cnt++]=i;
            phi[i]=i-1,mu[i]=-1;
        }
        for(int j=0;j<cnt && 1ll*i*prime[j]<maxn;++j) {
            notprime[i*prime[j]]=1;
            if(i%prime[j]==0) {
                phi[i*prime[j]]=phi[i]*prime[j];
				mu[i*prime[j]]=0;
                break;
            }
            phi[i*prime[j]]=phi[i]*(prime[j]-1);
            mu[i*prime[j]]=-mu[i];
        }
    }
}
```

基础可筛的 

素因数个数      $vis[i*prime[j]]=vis[i]+1$

约数个数  $d[i]$:约数个数. $num[i]$:i的最小质因数个数

```C++
if(i%prime[j]==0) {
    d[i*prime[j]]=d[i]/(num[i]+1)*(num[i]+2);
    num[i*prime[j]]=num[i]+1;
    break;
}
d[i*prime[j]]=d[i]*2;
num[i*prime[j]]=1;
```

### 区间筛

```C++
///区间筛
const int maxn = 1e6 + 5;
bool is_prime[maxn], is_prime_small[maxn];
ll prime[maxn];
ll prime_num = 0;
//对区间[a, b)的整数执行筛法，is_prime[i - a] = true <=> i 是素数
void segment_sieve(ll a, ll b) {
    for(int i = 0; (ll)i * i < b; i ++)  is_prime_small[i] = true;//对[2, sqrt(b)]进行初始化
    for(int i = 0; i < b - a; i ++)  is_prime[i] = true;
    for(int i = 2; (ll)i * i < b; i ++) {
        if(is_prime_small[i]) {
            for(ll j = 2 * i; (ll)j * j < b; j += i)    is_prime_small[j] = false;//筛[2, sqrt(b))
            for(ll j = max(2LL, (a + i - 1) / i) * i; j < b; j += i)    is_prime[j - a] = false;//筛[a,b)
        }
    }
    for(ll i = 0; i < b - a; i ++)
        if(is_prime[i]) prime[prime_num ++] = i + a;
}

```

### 素数测试和pollard_rho

- 1e15理论上1000个没问题.注意快速乘

```C++
ll mul(ll a, ll b, ll m) {
    return (a * b - ll((long double)a * b / m) * m + m) % m;
}
ll power(ll v, ll p, ll m) {
    ll r = 1;
    while (p) {
        if (p & 1) r=mul(r,v,m);
        v=mul(v,v,m);
        p >>= 1;
    }
    return r;
}
bool witness(ll a, ll p) {
    int k = 0;
    ll q = p - 1;
    while ((q & 1) == 0) ++k, q >>= 1;
    ll v = power(a, q, p);
    if (v == 1 || v == p - 1) return false; // probably prime number
    while (k-- != 0) {
        v = mul(v,v,p);
        if (v == p - 1) return false;
    }
    return true; // composite number
}
mt19937 rnd(233);
bool miller_rabin(ll p) {
    if (p == 1) return false;
    if (p == 2) return true;
    if (p % 2 == 0) return false;
    for (int i = 0; i != 50; ++i) {
        ll a = rnd() % (p - 1) + 1;
        if (witness(a, p)) return false;
    }
    return true;
}
ll pollard_rho(ll n, int a) {//依概率分解出n的一个因子
    ll x = 2, y = 2, d = 1, k = 0, i = 1;
    while(d == 1) {
        ++k;
        x = mul(x, x, n) + a;
        d = __gcd(x >= y ? x - y : y - x, n);
        if(k == i) { y = x; i <<= 1;}
    }
    if(d == n) return pollard_rho(n, a + 1);
    return d;
}

vi fac;
void decomp(ll n) {
    if(miller_rabin(n)) {
        fac.push_back(n);
        return;
    }
    ll d=pollard_rho(n,233);
    if(n!=d) decomp(n/d);
    decomp(d);
}
void getfac(ll n) {
    //fac.clear();
    if(n>1) decomp(n);
}
```

## ex_crt和ex_gcd

```C++
void ex_gcd(ll a, ll b, ll &d, ll &x, ll &y) {
    if (!b) {
        d = a, x = 1, y = 0;
        return;
    }
    ex_gcd(b, a % b, d, y, x);
    y -= x * (a / b);
}
//一堆理解
        //ax+by==c  d= g c d ; ax = c (mod b)  //x的最小整数解 一个特解
        //  可根据特解x得到 y=(c-a*x)/b;  后续可推出通解
/*     求y的最小正整数解 ax+by=c;  一对解x y
g=gcd
    ll t=a/g;  
    y=y%t+t;
    x=(g-y*b)/a;
    assert(a*x+y*b==g);
    x*=c/g;
    y*=c/g;

    x的版本反过来.. x=x0+(b/g)*i  y=y0-(a/g)*i;
                        */
        if(c%d) printf("FOREVER\n");
        else
        {
            a/=d;
            b/=d;
            c/=d;
            printf("%lld\n",(x%b*c%b+b)%b);
        }

///ax%b落在l~r区间最小的x
ll calc(int l, int r, int a, int b) {
    if (l>r || l==0) return 0;
    if (a>=b) a%=b;
    if (a==0) return -1;
    if ((l+a-1)/a<=r/a) return (l+a-1)/a; ///case 2
    ll y = calc((-r % a + a) % a, (-l % a + a) % a, b, a);
    if (y==-1) return -1;
    return (((1ll * b * y + l) + (a - 1)) / a);
}
        scanf("%d %d %d %d %d", &a, &b, &s, &l, &r);
        l = ((l - s) % b + b) % b;
        r = ((r - s) % b + b) % b;
        cout << calc(l, r, a, b) << '\n';///步长a 环长b

//中国剩余定理板子  ,模数数组1~n,余数数组1~n;
ll ex_crt(ll *m, ll *r, int n) {
    ll M = m[1], R = r[1], x, y, d;
    for (int i = 2; i <= n; ++i) {
        ex_gcd(M, m[i], d, x, y);
        if ((r[i] - R) % d) return -1;
        x = (r[i] - R) / d * x % (m[i] / d);
        R += x * M;
        M = M / d * m[i];
        R %= M;
    }
    return R > 0 ? R : R + M; //注意0
}
```

## 类欧

万能类欧 给出T组询问，每组用$n,a,b,c,k_1,k_2$来描述。

请你求出 $\sum _{x=0}^{n} x^{k_1}\lfloor\frac{ax+b}{c}\rfloor ^{k_2}$ 对1e9+7取模。 k1+k2<=10

```c++
///普通类欧几里得算法
ll solve(ll n,ll m,ll a,ll b) { // \sum_{i=0}^{n-1} (ai+b)/m
	ll res=0;
	if (a>=m) res+=(n-1)*n/2*(a/m),a%=m;
	if (b>=m) res+=n*(b/m),b%=m;
	ll y=(n*a+b)/m,x=(y*m-b);
	if (y==0) return res;
	res+=y*(n-(x+a-1)/a);
	res+=solve(y,a,m,(a-x%a)%a);
	return res;
}
//万能类欧
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 15, M = 1e9 + 7;
int f[100][N][N], C[N][N], A[N][N], k1, k2, a, b, c, n, T;
int ksm(int x, int y)
int S(int n, int m) {
    int s = 0;
    for (int i = 0, v = 1; i <= m + 1; i++, (v *= n) %= M)
        (s += A[m][i] * v) %= M;

    return s;
}
int solve(int k1, int k2, int a, int b, int c, int n, int dep) {
    if (f[dep][k1][k2] != -1)
        return f[dep][k1][k2];
    int v = 0;
    if (a == 0)return f[dep][k1][k2] = S(n, k1) * ksm(b / c, k2) % M;
    if (a >= c || b >= c) {
        for (int i = 0; i <= k2; i++)
            for (int j = 0; j <= k2 - i; j++) {
                int k = k2 - i - j;
                (v += C[k2][i] * C[k2 - i][j] % M * ksm(a / c, i) % M * ksm(b / c, j) % M * solve(k1 + i, k, a % c, b % c, c,
                        n, dep + 1)) %= M;
            }

        return f[dep][k1][k2] = v;
    }

    int m = (a * n + b) / c - 1;
    v = S(n, k1) * ksm(m + 1, k2) % M;

    for (int i = 0; i <= k2 - 1; i++)
        for (int j = 0; j <= k1 + 1; j++)
            (v += M - C[k2][i] * A[k1][j] % M * solve(i, j, c, c - b - 1, a, m, dep + 1) % M) %= M;

    return f[dep][k1][k2] = v;
}
signed main() {
    scanf("%lld", &T);
    C[0][0] = 1;
    for (int i = 1; i < N; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++)
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % M;
    }
    A[0][1] = A[0][0] = 1;
    for (int i = 1; i < N - 1; i++) {
        for (int j = 0; j <= i + 1; j++)
            A[i][j] = C[i + 1][j];
        for (int j = 0; j < i; j++)
            for (int k = 0; k <= j + 1; k++)
                (A[i][k] += M - C[i + 1][j] * A[j][k] % M) %= M;
        int Inv = ksm(i + 1, M - 2);
        for (int j = 0; j <= i + 1; j++)
            (A[i][j] *= Inv) %= M;
    }
    while (T--) {
        scanf("%lld%lld%lld%lld%lld%lld", &n, &a, &b, &c, &k1, &k2);
        memset(f, -1, sizeof f);
        printf("%lld\n", solve(k1, k2, a, b, c, n, 0));
    }
}
```

## BSGS

```C++
//求a^x mod p = b 其中(a,p)=1 最小的x O（sqrt(p)） 使用map多log
ll BSGS(ll a,ll b,ll p) {
    if(!a) return b?-1:1;
    if(b==1) return 0;
    unordered_map<ll,ll>mp;
    int m=ceil(sqrt(p)),ax=1;
    for(int i=0; i<m; i++) {///a^0 ... a^(m-1)
        mp[ax]=i; ///可提前 return 
        ax=ax*a%p;
    }
    ll am=quick(a,m);
    am=quick(am,mod-2);
    for(int i=0;i<m;++i) {///a^(im+j)
        if(mp.count(b)) return m*i+mp[b];
        b=b*am%p;
    }
    return -1;
}
```

ex_bsgs 

```C++
map<int,int>H;
int exBSGS(ll a,ll b,ll p) {
    H.clear();
    ll d=1,g=0,gcd; b%=p;
    if(b==1 || p==1) return 0;
    while((gcd=__gcd(a,p))^1) {
        if(b%gcd) return -1;
        b/=gcd; p/=gcd; d*=(a/gcd); d%=p; g++;
        if(d==b) return g;
    }
    int t=ceil(sqrt(p*1.0));
    ll now=1,x,y,tmpg;
    ex_gcd(d,p,tmpg,x,y);
    x=(x%p+p)%p;
    b*=x; b%=p; now=b;
    for (int i=0;i<t;++i,now*=a,now%=p) H[now]=i;
    int powt=quick(a,t,p); now=powt;
    for(int i=t;i<=t*t;i+=t,now*=powt,now%=p) if(H.find(now)!=H.end()) return i-H[now]+g;
    return -1;
}
```

## 原根

```C++
const int N=1e6+7;
int rt[N],cans,ans[N],factor[N],c2=0;
void getphi() {
    getprime and phi; 
    //2,4,p^e,2p^e,存在性判定
    rt[2]=rt[4]=1;
    for(int i=1;i<c1;++i) {
        for(int j=1;(1ll*j*prime[i])<maxn;j*=prime[i]) rt[j*prime[i]]=1;
        for(int j=2;(1ll*j*prime[i])<maxn;j*=prime[i]) rt[j*prime[i]]=1;
    }
}
int quick(int a,int b,int p)
void getfac(int p) {
    c2=0;
    for(int i=2;i*i<=p;++i)
        if(p%i==0) {
            factor[c2++]=i;
            while(p%i==0) p/=i;
        }
    if(p>1) factor[c2++]=p;
}
int find_smallest_primitive_root(int p) {//素数的话直接改p-1
    getfac(phi[p]);
    for(int i=1;i<=p;++i) {
        bool flag=true;
        if (quick(i,phi[p],p)!=1) continue;
        for(int j=0;j<c2;++j) {
            if (quick(i,phi[p]/factor[j],p)==1) {
                flag=false;
                break;
            }
        }
        if(flag) return i;
    }
    assert(0); return -1;
}
void getrt(int p,int x) {//x是最小原根,找所有原根
    cans=0;
    int cur=1;
    for(int i=1;i<=phi[p];++i) {
        cur=(1ll*cur*x)%p;
        if(__gcd(i,phi[p])==1) ans[cans++]=cur;
    }
}
```

## 组合数学

```C++
ll quick(ll x,ll n){
    ll res=1;
    while(n) {
        if(n&1) res=(res*x)%mod;
        x=x*x%mod;
        n>>=1;
    }
    return res;
}
ll inv(ll x) {return quick(x,mod-2);}
ll fac[maxn],invfac[maxn],Inv[maxn];
void init() {
    Inv[1]=1;
    for(int i=2;i<maxn;++i) Inv[i]=(ll)(mod-mod/i)*Inv[mod%i]%mod;
    fac[0]=1;
    for(int i=1;i<maxn;++i) fac[i]=(fac[i-1]*i)%mod;
    invfac[maxn-1]=inv(fac[maxn-1]);
    for(int i=maxn-2;i>=0;--i) invfac[i]=(invfac[i+1]*(i+1))%mod;
}
ll C(int n,int m) {
    if(n<m || m<0) return 0;
    return fac[n]*invfac[m]%mod*invfac[n-m]%mod;
}
//C还可以记忆化搜索 
//杨辉三角初始化递推计算
ll Catalan(int n) {
    return C(2*n,n)*inv(n+1)%mod;
}
const int maxn=1e2+7,mod=20090126;
ll stirling2[maxn][maxn],fac[maxn];
ll stirling1[maxn][maxn];
void init() {
    fac[0]=1;
    for(int i=1;i<maxn;++i) fac[i]=fac[i-1]*i%mod;
    for(int i=1;i<maxn;++i) { ///将n个不同元素构成m个圆排列的数目
        stirling1[i][0]=0,stirling1[i][i]=1;
        for(int j=1;j<i;++j) stirling1[i][j]=(stirling1[i-1][j-1]+(i-1)*stirling1[i-1][j]%mod)%mod;
    }
    for(int i=1;i<maxn;++i) {///将n个不同元素划分为m个无区别集合  有区别则分别乘j的排列
        stirling2[i][1]=stirling2[i][i]=1;
        for(int j=2;j<i;++j) stirling2[i][j]=(stirling2[i-1][j-1]+j*stirling2[i-1][j]%mod)%mod;
    }
}
```

### lucas定理

```C++
//4.Lucas定理计算 大组合数取模
//需要计算C[100000000009][500005] mod为素数且mod不是很大 1e5
const int maxn=1e6+10;
ll fac[maxn];
ll p;
void init() {
    fac[0]=1;
    for(int i=1;i<=p;++i) a[i]=(a[i-1]*i)%p;
}
ll quick(ll x,ll n)   
ll C(ll n,ll m) {
    if(m>n)return 0;
    return (fac[n]*quick(fac[m],p-2))%p*quick(fac[n-m],p-2)%p;
}
ll Lucas(ll n,ll m) {
    if(!m) return 1;
    return C(n%p,m%p)*Lucas(n/p,m/p)%p;
}
```

### polya

需要根据题目考虑，以下仅供参考

```C++
ll Polya(ll n,ll m) {//仅m==3
    ll ans=0;
    for(int i=0;i<m;++i) ans+=quick(n,__gcd(i*2,m*2));
    if(m&1) ans+=3*quick(n,4);
    ans/=6;
    return ans;
}
ll polya(int n) {///n很大 仅旋转同构
    ll ans=0;
    for(int i=1;1ll*i*i<=n;++i) {
        if(n%i==0) {
            ans=(ans+(1ll*Phi(n/i)%mod*quick(n,i-1))%mod)%mod; ///枚举约数 分母放在里面
            if(i*i!=n) ans=(ans+(1ll*Phi(i)%mod*quick(n,n/i-1))%mod)%mod;
        }
    }
    return ans;
}
```



## 多项式

### 函数卷积、置换快速幂

```c++
ll n,k;
void mul(ll a[],ll b[]) {
    memset(s,0,sizeof(s));
    for(int i=1;i*i<=n;++i) {
        s[i*i]=(s[i*i]+a[i]*b[i]%mod)%mod;
        for(int j=i+1;i*j<=n;++j) s[i*j]=(s[i*j]+a[i]*b[j]%mod+a[j]*b[i]%mod)%mod;
    }
    for(int i=1;i<=n;++i) a[i]=s[i];
}
void power(ll a[],ll p) {
    memset(ans,0,sizeof(ans));
    ans[1]=1;
    while(p) {
        if(p&1) mul(ans,a);
        mul(a,a);
        p>>=1;
    }
    for(int i=1;i<=n;++i) a[i]=ans[i];
}
int main() {
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;++i) scanf("%lld",&f[i]);
    power(f,inv(k));
    for(int i=1;i<=n;++i) printf("%lld%c",f[i],(i==n?'\n':' '));
    return 0;
}

///置换快速幂
int a[maxn],b[maxn],c[maxn],ans[maxn],pos[maxn],res[maxn];
///b原始序列 置换满足结合律 求b^x  就是ans[];
void mul(int a[],int b[],int n) {///置换乘法
    for(int i=1;i<=n;++i) c[i]=b[a[i]];
    for(int i=1;i<=n;++i) a[i]=c[i];
}
void qpow(int n,int x) {
    for(int i=1;i<=n;++i) ans[i]=i;
    while(x) {
        if(x&1) mul(ans,b,n);
        mul(b,b,n);
        x>>=1;
    }
    for(int i=1;i<=n;++i) pos[ans[i]]=i; //答案原序列继续置换ans
    for(int i=1;i<=n;++i) c[pos[i]]=res[i];
    for(int i=1;i<=n;++i) res[i]=c[i];
}
```

### 拉格朗日插值

```C++
/*
ll f(int k){//给点n个点 构造函数确定n-1次多项式 暴力O(n^2)拉格朗日插值求f(k);
    ll ans=0;
    for(int i=1;i<=n;++i) {
        ll s1=y[i]%mod,s2=1;  //分子 分母
        for(int j=1;j<=n;++j)
            if(i!=j) s1=s1*(k-x[j])%mod,s2=s2*((x[i]-x[j]%mod+mod)%mod)%mod;
        ans+=s1*inv(s2)%mod;
        ans=(ans+mod)%mod;
    }
    return ans;
}
*/

ll pre[maxn],suf[maxn],fac[maxn];
ll f(int k) {//此处求前缀和i^k,实际上是k+1次多项式,不给定点值,选取连续的点,优化O(k log) 还可线性处理逆元
    pre[0]=suf[k+3]=fac[0]=1;
    for(int i=1;i<=k+2;++i) pre[i]=1ll*pre[i-1]*(n-i)%mod;
    for(int i=k+2;i>=1;--i) suf[i]=1ll*suf[i+1]*(n-i)%mod;
    for(int i=1;i<=k+2;++i) fac[i]=1ll*fac[i-1]*i%mod;
    ll ans=0;
    ll y=0;
    for(int i=1;i<=k+2;++i) {//k+1次多项式,需要k+2个点插值
        y=(y+quick(i,k))%mod;   //注意此处的yi是k+1次多项式,yi指的是前缀和,而不是原函数
        ll a=pre[i-1]*suf[i+1]%mod;
        ll b=fac[i-1]*((k+2-i)&1?-1ll:1ll)*fac[k+2-i]%mod; //分母fac注意奇偶性
        ans=(ans+y*a%mod*inv(b)%mod)%mod;
    }
    return (ans+mod)%mod;
}

///n个点,求得0~n-1的多项式系数  答案a[0]~a[n-1] x[1]~x[n],y
ll a[maxn], b[maxn], c[maxn], temp[maxn];
ll x[maxn],y[maxn];
int n;
void mul(ll *f, int len, ll t){//len为多项式的次数+1，函数让多项式f变成f*(x+t)
    for(int i = len; i > 0; --i) temp[i] = f[i], f[i] = f[i-1];
    temp[0] = f[0], f[0] = 0;
    for(int i = 0; i <= len; ++i) f[i]=(f[i] + t*temp[i])%mod;
}
void dev(ll *f, ll *r, ll t){//f是被除多项式的系数，r保存f除以x+t的结果
    for(int i = 0; i <= n; ++i) temp[i] = f[i];
    for(int i = n; i > 0; --i){
        r[i-1]=temp[i];
        temp[i-1]=(temp[i-1]-t*temp[i]%mod+mod)%mod;
    }
    return;
}
void lglr() {
    memset(temp,0,sizeof(temp));memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));memset(a,0,sizeof a);
    b[1] = 1, b[0] = -x[1];
    for(int i = 2; i <= n; ++i) mul(b, i, -x[i]);//预处理(x-x1)*(x-x2)...*(x-xn)
    for(int i = 1; i <= n; ++i){
        ll fz = 1;
        for(int j = 1; j <= n; ++j){
            if(j == i) continue;
            fz = fz*(x[i]-x[j]+mod)%mod;
        }
        fz = quick(fz, mod-2);
        fz = fz*y[i]%mod;//得到多项式系数
        dev(b, c, -x[i]);//得到多项式，保存在b数组
        for(int j = 0; j < n; ++j) a[j] = (a[j] + fz*c[j]%mod)%mod;
    }
}
```

### FFT NTT

```C++
//任意模数分治fft 拆系数优化 模数非质数也行
namespace Poly {
    const long double pi=acosl(-1);
    struct C {
        long double x,y;
        C():x(0),y(0){}
        C(long double a,long double b):x(a),y(b){}
        C operator+(const C &b){return C(x+b.x,y+b.y);}
        C operator-(const C &b){return C(x-b.x,y-b.y);}
        C operator*(const C &b){return C(x*b.x-y*b.y,x*b.y+y*b.x);}
        C operator/(long double b){return C(x/b,y/b);}
    };
    int id[N];
    int init(int n) {
        int ret=1;
        for(;1<<ret<n;ret++);
        for(int i=0;i<1<<ret;i++) id[i]=id[i>>1]>>1|((i&1)<<(ret-1));
        return 1<<ret;
    }
    C getwl(int x,int tag) {
        return C(cosl(2*pi/x),tag*sinl(2*pi/x));
    }
    void fft(C *a,int len,int tag=1) {
        for(int i=0;i<len;i++) if (id[i]>i) std::swap(a[i],a[id[i]]);
        for (int l=1;l<len;l<<=1) {
            C wl=getwl(l*2,tag);
            for (int st=0;st<len;st+=l<<1) {
                C w(1,0),tmp;
                for (int i=st;i<st+l;i++,w=w*wl) tmp=a[i+l]*w,a[i+l]=a[i]-tmp,a[i]=a[i]+tmp;
            }
        }
        if (tag<0) for (int i=0;i<len;i++) a[i]=a[i]/len;
    }
    int mul(int *ret,int *a,int alen,int *b,int blen,int M) {
        static C c[N],d[N],e[N];
        int s=alen+blen-1,len=init(s);
        for (int i=0;i<alen;i++) c[i]=C(a[i]>>15,a[i]&0x7fff);
		std::fill(c+alen,c+len,C());
        for (int i=0;i<blen;i++) d[i]=C(b[i]>>15,b[i]&0x7fff);
		std::fill(d+blen,d+len,C());
        fft(c,len),fft(d,len);
        for (int i=0;i<len;i++) {
            int j=(len-i)&(len-1);
            e[i]=d[i]*C(0.5*(c[i].x+c[j].x),0.5*(c[i].y-c[j].y));
            d[i]=d[i]*C(0.5*(c[i].y+c[j].y),0.5*(c[j].x-c[i].x));
        }
        fft(e,len,-1),fft(d,len,-1);
        for (int i=0;i<s;i++) {
            ll x=roundl(e[i].x),y=roundl(e[i].y),z=roundl(d[i].x),w=roundl(d[i].y);
            ret[i]=(((x%M<<30)%M+((y+z)%M<<15)%M+w%M)%M+M)%M;
        }
        return s;
    }
}
int a[N<<1],tot;
struct P{
	int *p,len;
	void init() {//根据具体情况设定系数和次幂,注意指针保证数组不重
	    int x;
	    reads(x);
	    int len=x+1;
	    p=a+tot;
		this->len=len;
		for(int i=0;i<len;++i) p[i]=0;
		p[0]++,p[len-1]++;
		tot+=len;
	}
	void mul(const P &b,int mod) {
		len=Poly::mul(p,p,len,b.p,b.len,mod);
	}
};
#define mid ((l+r)>>1)
P solve(int l,int r,int p) {
	P ret;
	if(l==r) ret.init();
	else {
		ret=solve(l,mid,p);
		ret.mul(solve(mid+1,r,p),p);
	}
	return ret;
}

///ntt
constexpr ll mod = 998244353;
constexpr ll g = 3;
const int N = 1001000;
vector<int> r;
ll power(ll x,ll y){
    ll res=1;
    for(;y;y>>=1,x=x*x%mod)
    if(y&1)res=res*x%mod;
    return res;
}
struct Poly : vector<ll>{
    Poly(){}
    Poly(int n) : vector<ll>(n){}
    Poly(const initializer_list<ll>& list) : vector<ll>(list){}
    void dft(int n, bool inverse = false){
        if((int)r.size() != n){
            r.resize(n);
            r[1] = n >> 1;
            for(int i = 2; i < n; i += 1) r[i] = r[i >> 1] >> 1 | (i & 1 ? n >> 1 : 0);
        }
        resize(n);
        for(int i = 0; i < n; i += 1) if(i < r[i]) std::swap(at(i), at(r[i]));
        for(int d = 0; (1 << d) < n; d += 1){
            int m = 1 << d, m2 = m << 1;
            ll _w = power(inverse ? power(g, mod - 2) : g, (mod - 1) / m2);
            for(int i = 0; i < n; i += m2)
                for(int w = 1, j = 0; j < m; j += 1, w = w * _w % mod){
                    ll& x = at(i + j + m), &y = at(i + j), t = w * x % mod;
                    x = y - t;
                    if(x < 0) x += mod;
                    y += t;
                    if(y >= mod) y -= mod;
                }
        }
        if(inverse) for(int i = 0, inv = power(n, mod - 2); i < n; i += 1) at(i) = at(i) * inv % mod;
    }
    Poly operator * (const Poly& p)const{
        auto a = *this, b = p;
        int k = 1, n = size() + p.size() - 1;
        while(k < n) k <<= 1;
        a.dft(k);
        b.dft(k);
        for(int i = 0; i < k; i += 1) a[i] = a[i] * b[i] % mod;
        a.dft(k, true);
        a.resize(n);
        return a;
    }
    Poly inverse()const{
        Poly a = {power(at(0), mod - 2)};
        for(int n = 1; n < (int)size(); n <<= 1){
            int k = n << 2;
            auto b = *this, c = a;
            for(int i = n << 1; i < (int)b.size(); i += 1) b[i] = 0;
            b.dft(k);
            c.dft(k);
            for(int i = 0; i < k; i += 1) b[i] = b[i] * c[i] % mod * c[i] % mod;
            b.dft(k, true);
            a.resize(n << 1);
            for(int i = 0; i < (n << 1); i += 1) a[i] = (2 * a[i] + mod - b[i]) % mod;
        }
        a.resize(size());
        return a;
    }
    pair<Poly, Poly> operator / (const Poly& p){
        int n = size() - p.size() + 1;
        auto a = *this, b = p;
        reverse(a.begin(), a.end());
        reverse(b.begin(), b.end());
        a.resize(n);
        b.resize(n);
        auto q = a * b.inverse();
        q.resize(n);
        reverse(q.begin(), q.end());
        auto r = p * q;
        r.resize(p.size() - 1);
        for(int i = 0; i + 1 < (int)p.size(); i += 1){
            r[i] = at(i) - r[i];
            if(r[i] < 0) r[i] += mod;
        }
        return {q, r};
    }
    Poly log()const{
        int n = size();
        Poly a(n - 1);
        for(int i = 0; i + 1 < n; i += 1) a[i] = at(i + 1) * (i + 1) % mod;
        a = a * inverse();
        a.resize(n);
        for(int i = n - 1; i >= 0; i -= 1) a[i] = i ? a[i - 1] * power(i, mod - 2) % mod : 0;
        return a;
    }
    Poly exp()const{
        Poly a = {1};
        for(int n = 1; n < (int)size(); n <<= 1){
            int k = n << 2;
            auto b = a.log();
            b.resize(k);
            for(int i = 0; i < k; i += 1)
                b[i] = ((i < (int)size() ? at(i) : 0) + not i + mod - b[i]) % mod;
            a = a * b;
            a.resize(k);
        }
        a.resize(size());
        return a;
    }
    Poly mulT(const Poly& p)const{
        auto a = *this;
        reverse(a.begin(), a.end());
        a = a * p;
        a.resize(size());
        reverse(a.begin(), a.end());
        return a;
    }
    Poly eval(const Poly& x)const{
        #define tm ((tl + tr) >> 1)
        #define ls (v << 1)
        #define rs (ls | 1)
        vector<Poly> Q(x.size() << 2), P(x.size() << 2);
        Poly y(x.size());
        function<void(int, int, int)> dfs1 = [&](int v, int tl, int tr){
            if(tl == tr){
                Q[v].push_back(1);
                Q[v].push_back((mod - x[tm]) % mod);
                return;
            }
            dfs1(ls, tl, tm);
            dfs1(rs, tm + 1, tr);
            Q[v] = Q[ls] * Q[rs];
        };
        function<void(int, int, int)> dfs2 = [&](int v, int tl, int tr){
            if(tl == tr){
                y[tm] = P[v][0];
                return;
            }
            P[v].resize(tr - tl + 1);
            P[ls] = P[v].mulT(Q[rs]);
            P[rs] = P[v].mulT(Q[ls]);
            dfs2(ls, tl, tm);
            dfs2(rs, tm + 1, tr);
        };
        dfs1(1, 0, x.size() - 1);
        Q[1].resize(max(size(), x.size()));
        P[1] = mulT(Q[1].inverse());
        dfs2(1, 0, x.size() - 1);
        return y;
    }
};

//常数更优秀 from Holyk
namespace Polynomial {
using Poly = std::vector<int>;
constexpr int P(998244353), G(3);
inline void inc(int &x, int y) { (x += y) >= P ? x -= P : 0; }
inline int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k >>= 1, x = 1LL * x * x % P)
    if (k & 1) r = 1LL * r * x % P;
  return r;
}
template <int N>
std::array<int, N> getOmega() {
  std::array<int, N> w;
  for (int i = N >> 1, x = fpow(G, (P - 1) / N); i; i >>= 1, x = 1LL * x * x % P) {
    w[i] = 1;
    for (int j = 1; j < i; j++) w[i + j] = 1LL * w[i + j - 1] * x % P;
  }
  return w;
}
auto w = getOmega<1 << 20>();
inline Poly &dotEq(Poly &a, Poly b) {
  assert(a.size() == b.size());
  for (int i = 0; i < a.size(); i++) a[i] = 1LL * a[i] * b[i] % P;
  return a;
}
void dft(int *a, int n) {
  assert((n & n - 1) == 0);
  for (int k = n >> 1; k; k >>= 1) {
    for (int i = 0; i < n; i += k << 1) {
      for (int j = 0; j < k; j++) {
        int y = a[i + j + k];
        a[i + j + k] = 1LL * (a[i + j] - y + P) * w[k + j] % P;
        inc(a[i + j], y);
      }
    }
  }
}
void idft(int *a, int n) {
  assert((n & n - 1) == 0);
  for (int k = 1; k < n; k <<= 1) {
    for (int i = 0; i < n; i += k << 1) {
      for (int j = 0; j < k; j++) {
        int x = a[i + j], y = 1LL * a[i + j + k] * w[k + j] % P;
        a[i + j + k] = x - y < 0 ? x - y + P : x - y;
        inc(a[i + j], y);
      }
    }
  }
  for (int i = 0, inv = P - (P - 1) / n; i < n; i++)
    a[i] = 1LL * a[i] * inv % P;
  std::reverse(a + 1, a + n);
}
void dft(Poly &a) { dft(a.data(), a.size()); }
void idft(Poly &a) { idft(a.data(), a.size()); }
Poly operator*(Poly a, Poly b) {
  int len = a.size() + b.size() - 1;
  if (a.size() <= 8 || b.size() <= 8) {
    Poly c(len);
    for (size_t i = 0; i < a.size(); i++)
      for (size_t j = 0; j < b.size(); j++)
        c[i + j] = (c[i + j] + 1LL * a[i] * b[j]) % P;
    return c;
  }
  int n = 1 << std::__lg(len - 1) + 1;
  a.resize(n), b.resize(n);
  dft(a), dft(b);
  dotEq(a, b);
  idft(a);
  a.resize(len);
  return a;
}
}

//字符串匹配 s1模式串 求所有位置
void match_str(string s1,string s2,int m,int n) {
    reverse(s1.begin(),s1.end());
    for(int i=0;i<m;++i) a[i]=(s1[i]!='*')?(s1[i]-'a'+1):0;
    for(int i=0;i<n;++i) b[i]=(s2[i]!='*')?(s2[i]-'a'+1):0;
	int len = 1;
	for(; len <= n + m; len <<= 1);
	len_inv = quick(len, mod - 2);
	for(int i = 0; i <= len; i ++) rev[i] = (rev[i >> 1] >> 1) | ((i&1) * len >> 1);

    for(int i=0;i<len;++i) c1[i]=a[i]*a[i]*a[i],c2[i]=b[i];
    ntt(c1,len,1),ntt(c2,len,1);
    for(int i=0;i<len;++i) p[i]=(p[i]+c1[i]*c2[i]%mod)%mod;

    for(int i=0;i<len;++i) c1[i]=a[i],c2[i]=b[i]*b[i]*b[i];
    ntt(c1,len,1),ntt(c2,len,1);
    for(int i=0;i<len;++i) p[i]=(p[i]+c1[i]*c2[i]%mod)%mod;

    for(int i=0;i<len;++i) c1[i]=a[i]*a[i],c2[i]=b[i]*b[i];
    ntt(c1,len,1),ntt(c2,len,1);
    for(int i=0;i<len;++i) p[i]=(p[i]-2ll*c1[i]*c2[i]%mod+mod)%mod;
    ntt(p,len,-1);

    vector<int>ans;
    for(int i=m-1;i<n;++i) if(p[i]==0) ans.push_back(i-m+2);
    cout<<ans.size()<<'\n';
    for(auto &v:ans) cout<<v<<' ';
    cout<<'\n';
}
```

ntt模数 P=1004535809  g=3

构造卷积关系。固定差值对应的乘积，考虑反转另一个数组，得到卷积。

解决字符串匹配问题

### FWT

- $C_k=\sum_{i \oplus j=k} A_i B_j$

```C++
const int N=1<<18;//数最大 上界必须正好不能多
/// O(n*2^(n))
//模意义下
void fwt_or(int *a,int opt) {
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k)
                if(opt==1)a[i+j+k]=(a[j+k]+a[i+j+k])%mod;
                else a[i+j+k]=(a[i+j+k]+mod-a[j+k])%mod;
}
void fwt_and(int *a,int opt) {
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k)
                if(opt==1)a[j+k]=(a[j+k]+a[i+j+k])%mod;
                else a[j+k]=(a[j+k]+mod-a[i+j+k])%mod;
}
//inv2为2的逆元  inv2=mod/2+1;
void fwt_xor(int *a,int opt) {
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k) {
                int X=a[j+k],Y=a[i+j+k];
                a[j+k]=(X+Y)%mod;a[i+j+k]=(X+mod-Y)%mod;
                if(opt==-1)a[j+k]=1ll*a[j+k]*inv2%mod,a[i+j+k]=1ll*a[i+j+k]*inv2%mod;
            }
}
//or卷积
void fwt(ll *P,int opt) {
	for(int i=2;i<=N;i<<=1)
		for(int p=i>>1,j=0;j<N;j+=i)
			for(int k=j;k<j+p;++k)
				P[k+p]+=P[k]*opt;
}
//and卷积
void fwt(ll *P,int opt) {
	for(int i=2;i<=N;i<<=1)
		for(int p=i>>1,j=0;j<N;j+=i)
			for(int k=j;k<j+p;++k)
				P[k]+=P[k+p]*opt;
}
//异或卷积
void fwt(ll *P,int opt) {
	for(int i=2;i<=N;i<<=1)
		for(int p=i>>1,j=0;j<N;j+=i)
			for(int k=j;k<j+p;++k) {
				ll x=P[k],y=P[k+p];
				P[k]=(x+y);P[k+p]=x-y;
				if(opt==-1) P[k]=P[k]/2,P[k+p]=P[k+p]/2;
			}
}
///F[x]=sigma A_i[x&i=i] subset of x  超集只需判定条件改成==0
for(int i=0;i<20;++i) for(int j=0;j<(1<<20);++j) if(j&(1<<i)) f[j]+=f[j^(1<<i)];

//fmt SOSdp 子集卷积
const int maxn=1e6+7,inf=0x3f3f3f3f,mod=1e9+9;
int bc[1<<20],n,len;
int a[21][1<<20],b[21][1<<20],c[21][1<<20];
void fmt(int *f,int op) {
    for(int i=0;i<n;++i)
        for(int j=0;j<len;++j)
            if(j&(1<<i))
            {
                if(op==1) f[j]=(f[j]+f[j^(1<<i)])%mod;
                else f[j]=(f[j]-f[j^(1<<i)]+mod)%mod;
            }
}
int main() {
    cin>>n;
    len=1<<n;
    for(int i=1;i<len;++i) bc[i]=bc[i-(i&-i)]+1;
    for(int i=0;i<len;++i) cin>>a[bc[i]][i];
    for(int i=0;i<len;++i) cin>>b[bc[i]][i];
    for(int i=0;i<=n;++i) fmt(a[i],1),fmt(b[i],1);
    for(int i=0;i<=n;++i) for(int j=0;j<=i;++j) for(int s=0;s<len;++s) c[i][s]=(c[i][s]+1ll*a[j][s]*b[i-j][s]%mod)%mod;
    for(int i=0;i<=n;++i) fmt(c[i],-1);
    for(int i=0;i<len;++i) cout<<c[bc[i]][i]<<" ";
    cout<<'\n';
    return 0;
}

//任意多个子集的卷积 倍增处理
const int mod = 998244353;
int Len = 1 << 21, Base = 21;
inline void fmt_or(vector<int>& f,int op=1,int base=Base)//子集和
vector<int> pc;
void get_top(int sz) {
    pc.resize(sz, 0);
    for (int i = 1; i < sz; ++i) pc[i] = pc[i >> 1] + (i & 1);
}
vector<int> subset_conv(vector<int> A, vector<int> B, int base) {
    int len = 1 << base;
    vector<int> H(len);
    vector<vector<int> > siga(base + 1, vector<int>(len, 0)), sigb = siga, sigh = siga;
    for (int S = 0; S < len; ++S) siga[pc[S]][S] = A[S], sigb[pc[S]][S] = B[S];
    for (int i = 0; i <= base; ++i) {
        fmt_or(siga[i], 1, base);
        fmt_or(sigb[i], 1, base);
        for (int j = 0; j <= i; ++j)
            for (int S = 0; S < len; ++S) sigh[i][S] = mo(sigh[i][S] + muln(siga[j][S], sigb[i - j][S]));
        fmt_or(sigh[i], -1, base);
    }
    for (int S = 0; S < len; ++S) H[S] = sigh[pc[S]][S];
    return H;
}
vector<int> conv(const vector<int>& p) {
    //A[n][S] = \sum_{ T \in S-\{n\} } A[pc(T)][T] \cdot p[n][S-T]
    get_top(Len);
    vector<int> ret(Len, 0);
    ret[0] = 1;
    for (int n = 0; n < Base; ++n) {
        int ful = 1 << n;
        auto A = vector<int>(ret.begin(), ret.begin() + ful);
        auto B = vector<int>(p.begin() + ful, p.begin() + ful * 2);
        A = subset_conv(A, B, n);
        for (int i = ful; i < ful * 2; ++i) ret[i] = A[i - ful];
    }
    return ret;
}

int main() {
    int n, q, prob, b;
    vector<int> p(Len, 0);
    scanf("%d",&n);
    for(int i=1;i<=n;++i) {
        scanf("%d%d",&prob,&b);
        p[b] = mo(p[b] + prob);
    }
    auto ans = conv(p);
    scanf("%d",&q);
    while (q--) {
        scanf("%d",&b);
        printf("%d\n",ans[b]);
    }
    return 0;
}
```

## 矩阵

### 矩阵快速幂

```C++
const int v=2; //开维数
int d=2;//实际维数
struct matrix {
    ll m[v][v];
    void init() {memset(m,0,sizeof(m));for(int i=0;i<d;++i) m[i][i]=1;}
    void clear() {memset(m,0,sizeof(m));}
    matrix operator +(const matrix &o) const {
        matrix res={};
        for(int i=0;i<d;++i)
            for(int j=0;j<d;++j)
                res.m[i][j]=(m[i][j]+o.m[i][j])%mod;
        return res;
    }
    matrix operator *(const matrix &o) const {//优化常数展开此矩阵
        matrix res={};
        for(int i=0;i<d;i++)
            for(int j=0;j<d;j++)
                for(int k=0;k<d;k++)
                    res.m[i][j]=(res.m[i][j]+m[i][k]*o.m[k][j]%mod)%mod;
        return res;
    }
    matrix operator -(const matrix &o) const {
        matrix res={};
        for(int i=0;i<d;++i)
            for(int j=0;j<d;++j)
                res.m[i][j]=(m[i][j]-o.m[i][j]+mod)%mod;
        return res;
    }
}Ans, base;
inline void mat_quick(ll p) {
    Ans.init();
    base={1,1,1,0};
    while(p) {
        if(p & 1) Ans=Ans*base;
        base=base*base;
        p>>=1;
    }
}
```

### 高斯消元求解线性方程组

```c++
///很多姿势 消成主对角线 直接求解
///消成上三角 倒着带入求解  此种方便优化 
///解的个数参加bitset版
void gauss(int n) { //a[0~n-1][0~n] 最后一列为解 
    for(int j=0;j<n;++j) {
        int pivot=j;
        for(int i=j+1;i<n;++i) if(fabs(a[i][j])>fabs(a[pivot][j])) pivot=i;
        if(pivot!=j) swap(a[j],a[pivot]);
        if(fabs(a[j][j])<eps) {
            puts("Arbitrary Solution");   //全为1 自由元
            return;
        }
        for(int i=0;i<n;++i) { //每一行进行消元
            if(i!=j) {
                db tmp=a[i][j]/a[j][j];
                for(int k=j+1;k<=n;++k) a[i][k]-=a[j][k]*tmp;
            }
        }
    }
//    上述操作结束后，矩阵会变成这样
//    k1*a=e1
//    k2*b=e2
    for(int i=0;i<n;++i) printf("%.2f\n",a[i][n+1]/a[i][i]);
}
///取模版本
typedef vector<int> vi;
int a[maxn][maxn];
vi gauss_jordan(int n) {
    for(int i=0;i<n;i++) {
        int pivot=i;
        for(int j=i;j<n;j++) {
            if(a[j][i]) {
                pivot=j;
                break;
            }
        }
        if(pivot!=i) swap(a[i],a[pivot]);
        if(!a[i][i]) break;
        ll ib=quick(a[i][i],mod-2);
        for(int j=i+1;j<=n;j++) a[i][j]=1ll*a[i][j]*ib%mod;
        for(int j=i+1;j<n;j++) if(i!=j && a[j][i]) for(int k=n;k>=i+1;--k) a[j][k]=(a[j][k]-1ll*a[i][k]*a[j][i]%mod+mod)%mod;
    }
    vi x(n);///消成上三角 主对角线为1
    for(int j=n-1;j>=0;--j) { //回代得到解
        x[j]=a[j][n];
        for(int i=j-1;i>=0;--i) a[i][n]=(a[i][n]-1ll*a[i][j]*x[j]%mod+mod)%mod;
    }
    return x;
}
```

### 基尔霍夫矩阵(矩阵行列式求值)

无向图生成树计数

```C++
ll a[N][N];
ll determinant(int n){
	ll ans=1,mul,inv;
	for(int i=1;i<=n;++i){
        if(!a[i][i]) {
            for(int j=i+1;j<=n;++j) {
                if(a[j][i]) {
                    swap(a[i],a[j]);ans=mod-ans;
                    break;
                }
            }
        }
	    if(!a[i][i]) return 0;
	    inv=quick(a[i][i]),ans=ans*a[i][i]%mod;
	    for(int j=i+1;j<=n;++j){
			mul=inv*a[j][i]%mod;
	        for(int k=i;k<=n;++k) a[j][k]=(a[j][k]-mul*a[i][k]%mod+mod)%mod;
	    }
	}
	return ans;
}
```

main:维护度数，求n-1阶矩阵的行列式即可

```C++
D-E 对角线度数矩阵减去邻接边数矩阵
```

### 矩阵求逆

```C++
void gauss() {
    for(int j=1;j<=n;++j) //枚举列 其实也是行
    {
        int mx=j;
        for(int i=j+1;i<=n;++i) if(abs(a[i][j])>abs(a[mx][j])) mx=i;
        if(mx!=j) swap(a[mx],a[j]);
        if(!a[j][j]) {
            puts("No Solution");   //全为1 自由元
            return;
        }
        ll inv=quick(a[j][j],mod-2);
        for(int i=1;i<=n;++i) {  //每一行进行消元
            if(i!=j) {
                ll tmp=a[i][j]*inv%mod;
                for(int k=j;k<=n*2;++k) {//前面全消掉了为0
                    a[i][k]=(a[i][k]-a[j][k]*tmp%mod+mod)%mod;
                }
            }
        }
        for(int i=1;i<=2*n;++i) a[j][i]=a[j][i]*inv%mod;
    }
    for(int i=1;i<=n;++i)
        for(int j=n+1;j<=2*n;++j)
            printf("%lld%c",a[i][j],j==2*n?'\n':' ');
}
```

### bitset优化解异或方程组

```C++
bitset<207>a[207];
int gauss(int n) {///the number of free solution.
    int tmp=0;
    for (int i = 1, row = 1; i <= n; ++i, ++row) {
        int ma = -1;
        for (int j = row; j <= n; ++j) {
            if (a[j][i]) {
                ma = j;
                break ;
            }
        }
        if (ma == -1) {///尤其注意此处不能正常下一行
            --row;
            tmp++;
            continue ;
        }
        if (ma != row)    swap(a[row], a[ma]);
        for (int j = row + 1; j <= n; ++j)
            if (a[j][i])    a[j] ^= a[row];
    }
    return tmp;
}
///判断是否存在解
int n,k;
bitset<N>s[N];
bool check(int x) {///消元后 如果还有约束 只有一个 有变量直接对 不是异或方程组也是类似
    for(int i=1;i<n; i++) if(a[x][i])return true;
    return !a[x][n];
}
bool gauss() {///判断是否线性方程组有解  k行 n列, 第n列是解 实际k*n-1
    for(int i=1;i<=k;i++) if(!check(i)) return false;
    return true;
}
```

## 杂项

### 拆分数

```c++
    dp[0]=1;
    int mx=100000;
    for(int i=1;i<=mx;++i) {
        for(int j=1,tmp=1;(3*j*j-j)/2<=i;++j,tmp*=-1) {
            int x=(3*j*j-j)/2;
            int y=(3*j*j+j)/2;
            dp[i]=(dp[i]+tmp*dp[i-x]%mod+mod)%mod;
            if(i>=y) dp[i]=(dp[i]+tmp*dp[i-y]%mod+mod)%mod;
        }
    }
    int q,n,k;
    cin>>q;
    while(q--) {
        cin>>n>>k;
        ll ans=dp[n];//询问每个数出现次数<k的拆分数
        for(int j=1,tmp=-1;(3*j*j-j)/2*k<=n;++j,tmp*=-1) {
            int x=(3*j*j-j)/2*k;
            int y=(3*j*j+j)/2*k;
            ans=(ans+tmp*dp[n-x]%mod+mod)%mod;
            if(n>=y) ans=(ans+tmp*dp[n-y]%mod+mod)%mod;
        }
        cout<<ans<<'\n';
    }
```

### 线性基

```C++
//线性基板子
//求n维向量极大线性无关组，可以维护若干个bitset或者vector即可
struct Linebasis{
    ll p[65], b[65];
    int cnt; //秩
    bool flag; //是否极大线性无关组
    void init(){
        memset(p, 0, sizeof(p));memset(b, 0, sizeof(b));
        cnt = 0;
        flag = false;
    }
    bool insert(ll x){
        for(int i = 62; i >= 0; i--){
            if((x >> i) & 1){
                if(!p[i]){
                    p[i] = x;
                    break;
                }
                x ^= p[i];
            }
        }
        if(x) cnt++;
        else flag = true;
        return x > 0;
    }
    bool check(ll x) { //注意特判x=0 空集是否真的合法
        for(int i=62;i>=0;--i) if((x^p[i])<x) x^=p[i];
        return x==0;
    }
    Linebasis operator +(const Linebasis & r) const{
        Linebasis res = r;
        for(int i = 0; i <= 62; i++) {
            if(p[i])
                res.insert(p[i]);
        }
        return res;
    }
    ll querymax(ll x=0){
        ll res=x;
        for(int i=62;i>=0;--i) if((res ^ p[i]) > res) res ^= p[i];
        return res;
    }
    void rebuild(){
        for(int i = 62; i >= 0; i--){
            for(int j = i - 1; j >= 0; j--){
                if((p[i] >> j) & 1) p[i] ^= p[j];
            }
        }
        cnt = 0;
        for(int i = 0; i <= 62; i++){
            if(p[i]) b[cnt++] = p[i];
        }
    }
    ll kthmax(ll k){
        if(flag) k--;
        ll res = 0;
        if(!k) return 0;
        if(k >= (1ll << cnt)) return -1;
        for(int i = 62; i >= 0; i--){
            if((k >> i) & 1) res ^= b[i];
        }
        return res;
    }
}sol;
```

### 高级筛法(仅模板)素数前缀和杜教

```c++
///素数前缀和
const int N = sqrt(1e11) * 2 + 10;
bool isprime[N];
int prime[N / 10], pcnt;
ll sump[N / 10],n;
void Linear_Sieve(int maxn) {
	for(int i=0;i<=maxn;++i) isprime[i]=1;
	isprime[0] = isprime[1] = false;
	for(int i=2;i<=maxn;++i) {
		if(isprime[i])
		{
			prime[++ pcnt] = i;
			sump[pcnt] = sump[pcnt - 1] + i;
		}
		for(int j = 1; j <= pcnt && 1ll*prime[j]*i<=maxn;++j) {
			isprime[prime[j] * i] = false;
            if(!(i % prime[j])) break;
		}
	}
}
int d, id1[N], id2[N];
ll val[N], res[N];
#define id(x) (x <= d ? id1[x] : id2[n / (x)])
inline ll Sum(ll n) {
	return n * (n + 1) / 2 - 1;
}
ll Min25_Sieve(ll n) {
	int cnt = 0; d = sqrt((long long)(n));
	for (ll i = 1; i <= n; i = n / (n / i) + 1)
		val[id(n / i) = ++ cnt] = n / i, res[cnt] = Sum(n / i);

	for(int i=1;i<=pcnt;++i)
		for(int j = 1; j <= cnt && 1ll * prime[i] * prime[i] <= val[j]; ++ j)
			res[j] -= (res[id(val[j] / prime[i])] - sump[i - 1]) * prime[i];
	return res[id(n)];
}
int main () {
	scanf("%lld",&n);
	Linear_Sieve(sqrt(n + 0.5));
	printf("%lld\n",Min25_Sieve(n));
	return 0;
}
///前缀素数个数
typedef long long ll;
const int N = 5e6+2;
bool np[N];
int prime[N], pi[N];
int getprime() {
    int cnt = 0;
    np[0] = np[1] = true;
    pi[0] = pi[1] = 0;
    for(int i = 2; i < N; ++i) {
        if(!np[i]) prime[++cnt] = i;
        pi[i] = cnt;
        for(int j = 1; j <= cnt && i * prime[j] < N; ++j) {
            np[i * prime[j]] = true;
            if(i % prime[j] == 0)   break;
        }
    }
    return cnt;
}
const int M = 2;//为了减小内存可以不过是质数
const int PM = 2 * 3 * 5 ;//为了减小内存可以不过要按质数减小如去掉17
int phi[PM + 1][M + 1], sz[M + 1];

void init() {
    getprime();
    sz[0] = 1;
    for(int i = 0; i <= PM; ++i)  phi[i][0] = i;
    for(int i = 1; i <= M; ++i) {
        sz[i] = prime[i] * sz[i - 1];
        for(int j = 1; j <= PM; ++j) phi[j][i] = phi[j][i - 1] - phi[j / prime[i]][i - 1];
    }
}
int sqrt2(ll x) {
    ll r = (ll)sqrt(x - 0.1);
    while(r * r <= x)   ++r;
    return int(r - 1);
}
int sqrt3(ll x) {
    ll r = (ll)cbrt(x - 0.1);
    while(r * r * r <= x)   ++r;
    return int(r - 1);
}
ll getphi(ll x, int s) {
    if(s == 0)  return x;
    if(s <= M)  return phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];
    if(x <= prime[s]*prime[s])   return pi[x] - s + 1;
    if(x <= prime[s]*prime[s]*prime[s] && x < N) {
        int s2x = pi[sqrt2(x)];
        ll ans = pi[x] - (s2x + s - 2) * (s2x - s + 1) / 2;
        for(int i = s + 1; i <= s2x; ++i) ans += pi[x / prime[i]];
        return ans;
    }
    return getphi(x, s - 1) - getphi(x / prime[s], s - 1);
}
ll getpi(ll x) {
    if(x < N)   return pi[x];
    ll ans = getphi(x, pi[sqrt3(x)]) + pi[sqrt3(x)] - 1;
    for(int i = pi[sqrt3(x)] + 1, ed = pi[sqrt2(x)]; i <= ed; ++i) ans -= getpi(x / prime[i]) - i + 1;
    return ans;
}
ll lehmer_pi(ll x) {//小于等于n的素数有多少个O(n^(2/3))
    if(x < N)   return pi[x];
    int a = (int)lehmer_pi(sqrt2(sqrt2(x)));
    int b = (int)lehmer_pi(sqrt2(x));
    int c = (int)lehmer_pi(sqrt3(x));
    ll sum = getphi(x, a) +(ll)(b + a - 2) * (b - a + 1) / 2;
    for (int i = a + 1; i <= b; i++) {
        ll w = x / prime[i];
        sum -= lehmer_pi(w);
        if (i > c) continue;
        ll lim = lehmer_pi(sqrt2(w));
        for (int j = i; j <= lim; j++) sum -= lehmer_pi(w / prime[j]) - (j - 1);
    }
    return sum;
}

///杜教筛
ll smu[maxn],sphi[maxn];
int prime[maxn/5];
bool notprime[maxn];
int cnt;
unordered_map<int,ll>Smu,Sphi;  //里面不开ll 过不了 极限数据1 2147483647
//1401784457568941916 9569
void init() ///get mu phi presum
ll getsummu(int n) {
    if(n<maxn) return smu[n];
    if(Smu[n]) return Smu[n];
    ll res=1ll;
    for(ll l=2,r;l<=n;l=r+1) {
        r=n/(n/l);
        res-=(r-l+1)*getsummu(n/l);
    }
    return Smu[n]=res;
}
ll getsumphi(int n) {
    if(n<maxn) return sphi[n];
    if(Sphi[n]) return Sphi[n];
    ll res=(n+1ll)*n/2ll;
    for(ll l=2,r;l<=n;l=r+1) {
        r=n/(n/l);
        res-=(r-l+1)*getsumphi(n/l);
    }
    return Sphi[n]=res;
}
```

### BM

bm最短线性递推式(丢前若干项进去)

要求:

1. 线性递推
2. 所有数都有逆元
3. k阶线性递推需要 2k 项

```C++
#define vi vector<int>
const int mod=998244353;
vi mult_mod_f(const vi&x,const vi&y,const vi&f) {
    int n=x.size(),m=y.size();
    vi res(n+m-1);
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            res[i+j]=(res[i+j]+(ll)x[i]*y[j]%mod)%mod;
    int k=f.size();
    for(int i=n+m-2;i>=k-1;i--) {
        int w=(ll)res[i]*inv(f[k-1])%mod;
        for(int p=0;p<k-1;p++)
            res[i-(k-1)+p]=(res[i-(k-1)+p]-(ll)w*f[p]%mod+mod)%mod;
    }
    res.resize(k-1);
    return res;
}
vi getf(const vi& p) {
    int sz=p.size();
    vi f(sz+1);
    f[sz]=1;
    for(int i=0;i<sz;i++) f[sz-1-i]=mod-p[i];
    return f;
}
vi getweight(const vi&f,ll q) {
    int n=f.size();
    vi x(n);
    x[0]=1;
    vi z{0,1};
    while(q) {
        if(q&1) x=mult_mod_f(x,z,f);
        z=mult_mod_f(z,z,f);
        q>>=1;
    }
    return x;
}
vi BM(const vi& s) {
    vi C(1,1),B(1,1);
    int L=0,m=1,b=1;
    for(int n=0;n<s.size();n++) {
        ll d=0;
        for(int i=0;i<L+1;i++)
            d=(d+(ll)C[i]*s[n-i])%mod;
        if (d==0) ++m;
        else if (2*L<=n) {
            vi T=C;
            ll c=mod-d*quick(b,mod-2)%mod;
            while (C.size()<B.size()+m) C.push_back(0);
            for(int i=0;i<B.size();i++)
                C[i+m]=(C[i+m]+c*B[i])%mod;
            L=n+1-L; B=T; b=d; m=1;
        } else {
            ll c=mod-d*inv(b)%mod;
            while (C.size()<B.size()+m) C.push_back(0);
            for(int i=0;i<B.size();i++)
                C[i+m]=(C[i+m]+c*B[i])%mod;
            ++m;
        }
    }
    C.erase(C.begin());
    for(int i=0;i<C.size();i++) C[i]=(mod-C[i])%mod;
    return C;
}
int gao(const vi&a,ll n) {
    vi c=BM(a);//求解递推 O(a^2)
    vi f=getf(c);//构造f
    vi s=getweight(f,n);//求解系数 O(c^2logn)
    ll ret=0;
    for(int i=0;i<s.size();i++) ret=(ret+(ll)s[i]*a[i]%mod)%mod;
    return ret;
}
```

### tips

- 组合数、卡特兰数模数不是质数，考虑质因数分解.
- 至多至少的转化容斥，min-max容斥.
- $a_i + a_j-a_i \or a_j=a_i \& a_j$​

---

### 一些数论公式

- 当 $x\geq\phi(p)$ 时有 $a^x\equiv a^{x ; mod ; \phi(p) + \phi(p)}\pmod p$
- $\mu^2(n)=\sum_{d^2|n} \mu(d)$
- $\sum_{d|n} \varphi(d)=n$
- $\sum_{d|n} 2^{\omega(d)}=\sigma_0(n^2)$，其中 $\omega$ 是不同素因子个数
- $\sum_{d|n} \mu^2(d)=2^{\omega(d)}$
- 单位根反演 $[n|i]=\frac 1{n}\sum _{j=0} ^{n-1}\omega_k^{j*i}$ , 一般用原根 $\omega = g^{\frac{p-1}{n}}$。

### 一些数论函数求和的例子

- $\sum_{i=1}^n i[gcd(i, n)=1] = \frac {n \varphi(n) + [n=1]}{2}$
- $\sum_{i=1}^n \sum_{j=1}^m [gcd(i,j)=x]=\sum_d \mu(d) \lfloor \frac n {dx} \rfloor \lfloor \frac m {dx} \rfloor$
- $\sum_{i=1}^n \sum_{j=1}^m gcd(i, j) = \sum_{i=1}^n \sum_{j=1}^m \sum_{d|gcd(i,j)} \varphi(d) = \sum_{d} \varphi(d) \lfloor \frac nd \rfloor \lfloor \frac md \rfloor$
- $S(n)=\sum_{i=1}^n \mu(i)=1-\sum_{i=1}^n \sum_{d|i,d < i}\mu(d) \overset{t=\frac id}{=} 1-\sum_{t=2}^nS(\lfloor \frac nt \rfloor)$
  - 利用 $[n=1] = \sum_{d|n} \mu(d)$
- $S(n)=\sum_{i=1}^n \varphi(i)=\sum_{i=1}^n i-\sum_{i=1}^n \sum_{d|i,d<i} \varphi(i)\overset{t=\frac id}{=} \frac {i(i+1)}{2} - \sum_{t=2}^n S(\frac n t)$
  - 利用 $n = \sum_{d|n} \varphi(d)$
- $\sum_{i=1}^n \mu^2(i) = \sum_{i=1}^n \sum_{d^2|n} \mu(d)=\sum_{d=1}^{\lfloor \sqrt n \rfloor}\mu(d) \lfloor \frac n {d^2} \rfloor$
- $\sum_{i=1}^n \sum_{j=1}^n gcd^2(i, j)= \sum_{d} d^2 \sum_{t} \mu(t) \lfloor \frac n{dt} \rfloor ^2 \ \overset{x=dt}{=} \sum_{x} \lfloor \frac nx \rfloor ^ 2 \sum_{d|x} d^2 \mu(\frac xd)$
- $\sum_{i=1}^n \varphi(i)=\frac 12 \sum_{i=1}^n \sum_{j=1}^n [i \perp j] - 1=\frac 12 \sum_{i=1}^n \mu(i) \cdot\lfloor \frac n i \rfloor ^2-1$

### 斐波那契数列性质

- $F_{a+b}=F_{a-1} \cdot F_b+F_a \cdot F_{b+1}$
- $F_1+F_3+\dots +F_{2n-1} = F_{2n},F_2 + F_4 + \dots + F_{2n} = F_{2n + 1} - 1$
- $\sum_{i=1}^n F_i = F_{n+2} - 1$
- $\sum_{i=1}^n F_i^2 = F_n \cdot F_{n+1}$
- $F_n^2=(-1)^{n-1} + F_{n-1} \cdot F_{n+1}$
- $gcd(F_a, F_b)=F_{gcd(a, b)}$
- 模 $n$ 周期（皮萨诺周期）
  - $\pi(p^k) = p^{k-1} \pi(p)$
  - $\pi(nm) = lcm(\pi(n), \pi(m)), \forall n \perp m$
  - $\pi(2)=3, \pi(5)=20$
  - $\forall p \equiv \pm 1\pmod {10}, \pi(p)|p-1$
  - $\forall p \equiv \pm 2\pmod {5}, \pi(p)|2p+2$

### 常见生成函数

- $(1+ax)^n=\sum_{k=0}^n \binom {n}{k} a^kx^k$
- $\dfrac{1-x^{r+1}}{1-x}=\sum_{k=0}^nx^k$
- $\dfrac1{1-ax}=\sum_{k=0}^{\infty}a^kx^k$
- $\dfrac 1{(1-x)^2}=\sum_{k=0}^{\infty}(k+1)x^k$
- $\dfrac1{(1-x)^n}=\sum_{k=0}^{\infty} \binom{n+k-1}{k}x^k$
- $e^x=\sum_{k=0}^{\infty}\dfrac{x^k}{k!}$
- $\ln(1+x)=\sum_{k=0}^{\infty}\dfrac{(-1)^{k+1}}{k}x^k$

### 佩尔方程

若一个丢番图方程具有以下的形式：$x^2 - ny^2= 1$。且 $n$ 为正整数，则称此二元二次不定方程为**佩尔方程**。

若 $n$ 是完全平方数，则这个方程式只有平凡解 $(\pm 1,0)$（实际上对任意的 $n$，$(\pm 1,0)$ 都是解）。对于其余情况，拉格朗日证明了佩尔方程总有非平凡解。而这些解可由 $\sqrt{n}$ 的连分数求出。

$x = [a_0; a_1, a_2, a_3]=x = a_0 + \cfrac{1}{a_1 + \cfrac{1}{a_2 + \cfrac{1}{a_3 + \cfrac{1}{\ddots,}}}}$

设 $\tfrac{p_i}{q_i}$ 是 $\sqrt{n}$ 的连分数表示：$[a_{0}; a_{1}, a_{2}, a_{3}, ,\ldots ]$ 的渐近分数列，由连分数理论知存在 $i$ 使得 $(p_i,q_i)$ 为佩尔方程的解。取其中最小的 $i$，将对应的 $(p_i,q_i)$ 称为佩尔方程的基本解，或最小解，记作 $(x_1,y_1)$，则所有的解 $(x_i,y_i)$ 可表示成如下形式：$x_{i}+y_{i}{\sqrt n}=(x_{1}+y_{1}{\sqrt n})^{i}$。或者由以下的递回关系式得到：

$\displaystyle x_{i+1} = x_1 x_i + n y_1 y_i$, $\displaystyle y_{{i+1}}=x_{1}y_{i}+y_{1}x_{i}$。

**但是：**佩尔方程千万不要去推（虽然推起来很有趣，但结果不一定好看，会是两个式子）。记住佩尔方程结果的形式通常是 $a_n=ka_{n−1}−a_{n−2}$（$a_{n−2}$ 前的系数通常是 $−1$）。暴力 / 凑出两个基础解之后加上一个 $0$，容易解出 $k$ 并验证。

### Burnside & Polya

- $|X/G|={\frac {1}{|G|}}\sum _{{g\in G}}|X^{g}|$

注：$X^g$ 是 $g$ 下的不动点数量，也就是说有多少种东西用 $g$ 作用之后可以保持不变。

- $|Y^X/G| = \frac{1}{|G|}\sum_{g \in G} m^{c(g)}$

注：用 $m$ 种颜色染色，然后对于某一种置换 $g$，有 $c(g)$ 个置换环，为了保证置换后颜色仍然相同，每个置换环必须染成同色。

### 皮克定理

$2S = 2a+b-2$

- $S$ 多边形面积
- $a$ 多边形内部点数
- $b$ 多边形边上点数

### 莫比乌斯反演

- $g(n) = \sum_{d|n} f(d) \Leftrightarrow f(n) = \sum_{d|n} \mu (d) g( \frac{n}{d})$
- $f(n)=\sum_{n|d}g(d) \Leftrightarrow g(n)=\sum_{n|d} \mu(\frac{d}{n}) f(d)$

### 低阶等幂求和

- $\sum_{i=1}^{n} i^{1} = \frac{n(n+1)}{2} = \frac{1}{2}n^2 +\frac{1}{2} n$
- $\sum_{i=1}^{n} i^{2} = \frac{n(n+1)(2n+1)}{6} = \frac{1}{3}n^3 + \frac{1}{2}n^2 + \frac{1}{6}n$
- $\sum_{i=1}^{n} i^{3} = \left[\frac{n(n+1)}{2}\right]^{2} = \frac{1}{4}n^4 + \frac{1}{2}n^3 + \frac{1}{4}n^2$
- $\sum_{i=1}^{n} i^{4} = \frac{n(n+1)(2n+1)(3n^2+3n-1)}{30} = \frac{1}{5}n^5 + \frac{1}{2}n^4 + \frac{1}{3}n^3 - \frac{1}{30}n$
- $\sum_{i=1}^{n} i^{5} = \frac{n^{2}(n+1)^{2}(2n^2+2n-1)}{12} = \frac{1}{6}n^6 + \frac{1}{2}n^5 + \frac{5}{12}n^4 - \frac{1}{12}n^2$

### 一些组合公式

- 错排公式：$D_1=0,D_2=1,D_n=(n-1)(D_{n-1} + D_{n-2})=n!(\frac 1{2!}-\frac 1{3!}+\dots + (-1)^n\frac 1{n!})=\lfloor \frac{n!}e + 0.5 \rfloor$
- 卡塔兰数（$n$ 对括号合法方案数，$n$ 个结点二叉树个数，$n\times n$ 方格中对角线下方的单调路径数，凸 $n+2$ 边形的三角形划分数，$n$ 个元素的合法出栈序列数）：$C_n=\frac 1{n+1}\binom {2n}n=\frac{(2n)!}{(n+1)!n!}$

