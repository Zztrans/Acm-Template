# 数学 or 数论

## 素数

### 线性筛

```c++
bool notprime[maxn];
int prime[maxn],cnt;
int mu[maxn],phi[maxn];
void getprime() {
    notprime[0]=notprime[1]=1;phi[1]=mu[1]=1;
    cnt=0;
    for(int i=2;i<maxn;++i) {
        if(!notprime[i]) {
            prime[cnt++]=i;
            phi[i]=i-1,mu[i]=-1;
        }
        for(int j=0;j<cnt && 1ll*i*prime[j]<maxn;++j) {
            notprime[i*prime[j]]=1;
            if(i%prime[j]==0) {
                phi[i*prime[j]]=phi[i]*prime[j];
				mu[i*prime[j]]=0;
                break;
            }
            phi[i*prime[j]]=phi[i]*(prime[j]-1);
            mu[i*prime[j]]=-mu[i];
        }
    }
}
```

基础可筛的 

素因数个数      $vis[i*prime[j]]=vis[i]+1$

约数个数  $d[i]$:约数个数. $num[i]$:i的最小质因数个数

```C++
if(i%prime[j]==0) {
    d[i*prime[j]]=d[i]/(num[i]+1)*(num[i]+2);
    num[i*prime[j]]=num[i]+1;
    break;
}
d[i*prime[j]]=d[i]*2;
num[i*prime[j]]=1;
```

### 区间筛

```C++
///区间筛
const int maxn = 1e6 + 5;
bool is_prime[maxn], is_prime_small[maxn];
ll prime[maxn];
ll prime_num = 0;
//对区间[a, b)的整数执行筛法，is_prime[i - a] = true <=> i 是素数
void segment_sieve(ll a, ll b) {
    for(int i = 0; (ll)i * i < b; i ++)  is_prime_small[i] = true;//对[2, sqrt(b)]进行初始化
    for(int i = 0; i < b - a; i ++)  is_prime[i] = true;
    for(int i = 2; (ll)i * i < b; i ++) {
        if(is_prime_small[i]) {
            for(ll j = 2 * i; (ll)j * j < b; j += i)    is_prime_small[j] = false;//筛[2, sqrt(b))
            for(ll j = max(2LL, (a + i - 1) / i) * i; j < b; j += i)    is_prime[j - a] = false;//筛[a,b)
        }
    }
    for(ll i = 0; i < b - a; i ++)
        if(is_prime[i]) prime[prime_num ++] = i + a;
}

```

### 素数测试和pollard_rho

- 1e18理论上1000个只要1.5s，注意快速乘

```C++
vector<ll>fac;
namespace Rho {
    ll mul(ll a,ll b,ll m) {return (a * b - ll((long double)a * b / m) * m + m) % m;}
    ll power(ll x,ll n,ll mod){
        ll res=1;
        while(n) {
            if(n&1) res=mul(res,x,mod);
            x=mul(x,x,mod);
            n>>=1;
        }
        return res;
    }
    vector<ll> bases = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
    bool isprime(ll n) {
        if (n<2)    return 0;
        if (n%2==0)   return n==2;
        ll s = __builtin_ctzll(n-1), d = n>>s;
        for (ll x: bases) {
            ll p = power(x%n, d, n), t = s;
            while (p!=1 && p!=n-1 && x%n && t--) p = mul(p, p, n);
            if (p!=n-1 && t != s) return 0;
        }
        return 1;
    }
    mt19937_64 rnd(233);
    ll FindFactor(ll n) {///Returns a proper divisor if n is composite, n otherwise
        if (n == 1 || isprime(n)) return n;
        ll c = 1, x = 0, y = 0, t = 0, prod = 2, x0 = 1, q;
        auto f = [&](ll X) { return mul(X, X, n) + c;};
        while (t++ % 128 || __gcd(prod, n) == 1) {
            if (x == y) c = rnd()%(n-1)+1, x = x0, y = f(x);
            if ((q = mul(prod, max(x, y) - min(x, y), n))) prod = q;
            x = f(x), y = f(f(y));
        }
        return __gcd(prod, n);
    }
    void factorize(ll x) { ///Returns all prime factors
        if(x==1) return;
        ll a=FindFactor(x),b=x/a;
        if(a==x) {fac.push_back(x);return;}
        factorize(a),factorize(b);
    }
}
```

### 原根

```c++
const int N=1e6+7;
int rt[N],cans,ans[N],factor[N],c2=0;
void getphi() {
    getprime and phi; 
    //2,4,p^e,2p^e,存在性判定
    rt[2]=rt[4]=1;
    for(int i=1;i<c1;++i) {
        for(int j=1;(1ll*j*prime[i])<maxn;j*=prime[i]) rt[j*prime[i]]=1;
        for(int j=2;(1ll*j*prime[i])<maxn;j*=prime[i]) rt[j*prime[i]]=1;
    }
}
int quick(int a,int b,int p)
void getfac(int p) {
    c2=0;
    for(int i=2;i*i<=p;++i)
        if(p%i==0) {
            factor[c2++]=i;
            while(p%i==0) p/=i;
        }
    if(p>1) factor[c2++]=p;
}
int find_smallest_primitive_root(int p) {//素数的话直接改p-1
    getfac(phi[p]);
    for(int i=1;i<=p;++i) {
        bool flag=true;
        if (quick(i,phi[p],p)!=1) continue;
        for(int j=0;j<c2;++j) {
            if (quick(i,phi[p]/factor[j],p)==1) {
                flag=false;
                break;
            }
        }
        if(flag) return i;
    }
    assert(0); return -1;
}
void getrt(int p,int x) {//x是最小原根,找所有原根
    cans=0;
    int cur=1;
    for(int i=1;i<=phi[p];++i) {
        cur=(1ll*cur*x)%p;
        if(__gcd(i,phi[p])==1) ans[cans++]=cur;
    }
}
```

## ex_crt和ex_gcd

```C++
void ex_gcd(ll a, ll b, ll &d, ll &x, ll &y) {
    if (!b) {
        d = a, x = 1, y = 0;
        return;
    }
    ex_gcd(b, a % b, d, y, x);
    y -= x * (a / b);
}
//一堆理解
        //ax+by==c  d= g c d ; ax = c (mod b)  //x的最小整数解 一个特解
        //  可根据特解x得到 y=(c-a*x)/b;  后续可推出通解
/*     求y的最小正整数解 ax+by=c;  一对解x y
g=gcd
    ll t=a/g;  
    y=y%t+t;
    x=(g-y*b)/a;
    assert(a*x+y*b==g);
    x*=c/g;
    y*=c/g;
    
    x的版本反过来.. x=x0+(b/g)*i  y=y0-(a/g)*i;
                        */
        if(c%d) printf("FOREVER\n");
        else
        {
            a/=d;
            b/=d;
            c/=d;
            printf("%lld\n",(x%b*c%b+b)%b);
        }

///ax%b落在l~r区间最小的x
ll calc(int l, int r, int a, int b) {
    if (l>r || l==0) return 0;
    if (a>=b) a%=b;
    if (a==0) return -1;
    if ((l+a-1)/a<=r/a) return (l+a-1)/a; ///case 2
    ll y = calc((-r % a + a) % a, (-l % a + a) % a, b, a);
    if (y==-1) return -1;
    return (((1ll * b * y + l) + (a - 1)) / a);
}
        scanf("%d %d %d %d %d", &a, &b, &s, &l, &r);
        l = ((l - s) % b + b) % b;
        r = ((r - s) % b + b) % b;
        cout << calc(l, r, a, b) << '\n';///步长a 环长b

//中国剩余定理板子  ,模数数组1~n,余数数组1~n;
ll ex_crt(ll *m, ll *r, int n) {
    ll M = m[1], R = r[1], x, y, d;
    for (int i = 2; i <= n; ++i) {
        ex_gcd(M, m[i], d, x, y);
        if ((r[i] - R) % d) return -1;
        x = (r[i] - R) / d * x % (m[i] / d); //防爆ll用mul
        R += x * M;
        M = M / d * m[i];
        R %= M;
    }
    return R > 0 ? R : R + M; //注意0
}
```

## 类欧

万能类欧 给出T组询问，每组用$n,a,b,c,k_1,k_2$来描述。

请你求出 $\sum _{x=0}^{n} x^{k_1}\lfloor\frac{ax+b}{c}\rfloor ^{k_2}$ 对1e9+7取模。 k1+k2<=10

```c++
///普通类欧几里得算法
ll solve(ll n,ll m,ll a,ll b) { // \sum_{i=0}^{n-1} (ai+b)/m
	ll res=0;
	if (a>=m) res+=(n-1)*n/2*(a/m),a%=m;
	if (b>=m) res+=n*(b/m),b%=m;
	ll y=(n*a+b)/m,x=(y*m-b);
	if (y==0) return res;
	res+=y*(n-(x+a-1)/a);
	res+=solve(y,a,m,(a-x%a)%a);
	return res;
}
//万能类欧
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 15, M = 1e9 + 7;
int f[100][N][N], C[N][N], A[N][N], k1, k2, a, b, c, n, T;
int ksm(int x, int y)
int S(int n, int m) {
    int s = 0;
    for (int i = 0, v = 1; i <= m + 1; i++, (v *= n) %= M)
        (s += A[m][i] * v) %= M;
    return s;
}
int solve(int k1, int k2, int a, int b, int c, int n, int dep) {
    if (f[dep][k1][k2] != -1)
        return f[dep][k1][k2];
    int v = 0;
    if (a == 0)return f[dep][k1][k2] = S(n, k1) * ksm(b / c, k2) % M;
    if (a >= c || b >= c) {
        for (int i = 0; i <= k2; i++)
            for (int j = 0; j <= k2 - i; j++) {
                int k = k2 - i - j;
                (v += C[k2][i] * C[k2 - i][j] % M * ksm(a / c, i) % M * ksm(b / c, j) % M * solve(k1 + i, k, a % c, b % c, c,
                        n, dep + 1)) %= M;
            }
        return f[dep][k1][k2] = v;
    }
    int m = (a * n + b) / c - 1;
    v = S(n, k1) * ksm(m + 1, k2) % M;
    for (int i = 0; i <= k2 - 1; i++)
        for (int j = 0; j <= k1 + 1; j++)
            (v += M - C[k2][i] * A[k1][j] % M * solve(i, j, c, c - b - 1, a, m, dep + 1) % M) %= M;
    return f[dep][k1][k2] = v;
}
signed main() {
    scanf("%lld", &T);
    init C_i_j;
    A[0][1] = A[0][0] = 1;
    for (int i = 1; i < N - 1; i++) {
        for (int j = 0; j <= i + 1; j++)
            A[i][j] = C[i + 1][j];
        for (int j = 0; j < i; j++)
            for (int k = 0; k <= j + 1; k++)
                (A[i][k] += M - C[i + 1][j] * A[j][k] % M) %= M;
        int Inv = ksm(i + 1, M - 2);
        for (int j = 0; j <= i + 1; j++)
            (A[i][j] *= Inv) %= M;
    }
    while (T--) {
        scanf("%lld%lld%lld%lld%lld%lld", &n, &a, &b, &c, &k1, &k2);
        memset(f, -1, sizeof f);
        printf("%lld\n", solve(k1, k2, a, b, c, n, 0));
    }
}
```

## BSGS

```C++
//求a^x mod p = b 其中(a,p)=1 最小的x O（sqrt(p)） 使用map多log
ll BSGS(ll a,ll b,ll p) {
    if(!a) return b?-1:1;
    if(b==1) return 0;
    unordered_map<ll,ll>mp;
    int m=ceil(sqrt(p)),ax=1;
    for(int i=0; i<m; i++) {///a^0 ... a^(m-1)
        mp[ax]=i; ///可提前 return 
        ax=ax*a%p;
    }
    ll am=quick(a,m);
    am=quick(am,mod-2);
    for(int i=0;i<m;++i) {///a^(im+j)
        if(mp.count(b)) return m*i+mp[b];
        b=b*am%p;
    }
    return -1;
}
```

ex_bsgs 

```C++
map<int,int>H;
int exBSGS(ll a,ll b,ll p) {
    H.clear();
    ll d=1,g=0,gcd; b%=p;
    if(b==1 || p==1) return 0;
    while((gcd=__gcd(a,p))^1) {
        if(b%gcd) return -1;
        b/=gcd; p/=gcd; d*=(a/gcd); d%=p; g++;
        if(d==b) return g;
    }
    int t=ceil(sqrt(p*1.0));
    ll now=1,x,y,tmpg;
    ex_gcd(d,p,tmpg,x,y);
    x=(x%p+p)%p;
    b*=x; b%=p; now=b;
    for (int i=0;i<t;++i,now*=a,now%=p) H[now]=i;
    int powt=quick(a,t,p); now=powt;
    for(int i=t;i<=t*t;i+=t,now*=powt,now%=p) if(H.find(now)!=H.end()) return i-H[now]+g;
    return -1;
}
```

## 组合数学

```C++
ll quick(ll x,ll n){
    ll res=1;
    while(n) {
        if(n&1) res=(res*x)%mod;
        x=x*x%mod;
        n>>=1;
    }
    return res;
}
ll inv(ll x) {return quick(x,mod-2);}
ll fac[maxn],invfac[maxn],Inv[maxn];
void init() {
    Inv[1]=1;
    for(int i=2;i<maxn;++i) Inv[i]=(ll)(mod-mod/i)*Inv[mod%i]%mod;
    fac[0]=1;
    for(int i=1;i<maxn;++i) fac[i]=(fac[i-1]*i)%mod;
    invfac[maxn-1]=inv(fac[maxn-1]);
    for(int i=maxn-2;i>=0;--i) invfac[i]=(invfac[i+1]*(i+1))%mod;
}
ll C(int n,int m) {
    if(n<m || m<0) return 0;
    return fac[n]*invfac[m]%mod*invfac[n-m]%mod;
}
//C还可以记忆化搜索 
//杨辉三角初始化递推计算
ll Catalan(int n) {
    return C(2*n,n)*inv(n+1)%mod;
}
const int maxn=1e2+7,mod=20090126;
ll stirling2[maxn][maxn],fac[maxn];
ll stirling1[maxn][maxn];
void init() {
    fac[0]=1;
    for(int i=1;i<maxn;++i) fac[i]=fac[i-1]*i%mod;
    for(int i=1;i<maxn;++i) { ///将n个不同元素构成m个圆排列的数目
        stirling1[i][0]=0,stirling1[i][i]=1;
        for(int j=1;j<i;++j) stirling1[i][j]=(stirling1[i-1][j-1]+(i-1)*stirling1[i-1][j]%mod)%mod;
    }
    for(int i=1;i<maxn;++i) {///将n个不同元素划分为m个无区别集合  有区别则分别乘j的排列
        stirling2[i][1]=stirling2[i][i]=1;
        for(int j=2;j<i;++j) stirling2[i][j]=(stirling2[i-1][j-1]+j*stirling2[i-1][j]%mod)%mod;
    }
}
```

### lucas定理

```C++
//4.Lucas定理计算 大组合数取模
//需要计算C[100000000009][500005] mod为素数且mod不是很大 1e5
const int maxn=1e6+10;
ll fac[maxn];
ll p;
void init() {
    fac[0]=1;
    for(int i=1;i<=p;++i) a[i]=(a[i-1]*i)%p;
}
ll quick(ll x,ll n)   
ll C(ll n,ll m) {
    if(m>n)return 0;
    return (fac[n]*quick(fac[m],p-2))%p*quick(fac[n-m],p-2)%p;
}
ll Lucas(ll n,ll m) {
    if(!m) return 1;
    return C(n%p,m%p)*Lucas(n/p,m/p)%p;
}
```

### polya

需要根据题目考虑，以下仅供参考

```C++
ll Polya(ll n,ll m) {//仅m==3
    ll ans=0;
    for(int i=0;i<m;++i) ans+=quick(n,__gcd(i*2,m*2));
    if(m&1) ans+=3*quick(n,4);
    ans/=6;
    return ans;
}
ll polya(int n) {///n很大 仅旋转同构
    ll ans=0;
    for(int i=1;1ll*i*i<=n;++i) {
        if(n%i==0) {
            ans=(ans+(1ll*Phi(n/i)%mod*quick(n,i-1))%mod)%mod; ///枚举约数 分母放在里面
            if(i*i!=n) ans=(ans+(1ll*Phi(i)%mod*quick(n,n/i-1))%mod)%mod;
        }
    }
    return ans;
}
```

## 多项式

### 函数卷积、置换快速幂

```c++
ll n,k;
void mul(ll a[],ll b[]) {
    memset(s,0,sizeof(s));
    for(int i=1;i*i<=n;++i) {
        s[i*i]=(s[i*i]+a[i]*b[i]%mod)%mod;
        for(int j=i+1;i*j<=n;++j) s[i*j]=(s[i*j]+a[i]*b[j]%mod+a[j]*b[i]%mod)%mod;
    }
    for(int i=1;i<=n;++i) a[i]=s[i];
}
void power(ll a[],ll p) {
    memset(ans,0,sizeof(ans));
    ans[1]=1;
    while(p) {
        if(p&1) mul(ans,a);
        mul(a,a);
        p>>=1;
    }
    for(int i=1;i<=n;++i) a[i]=ans[i];
}
int main() {
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;++i) scanf("%lld",&f[i]);
    power(f,inv(k));
    for(int i=1;i<=n;++i) printf("%lld%c",f[i],(i==n?'\n':' '));
    return 0;
}

///置换快速幂
int a[maxn],b[maxn],c[maxn],ans[maxn],pos[maxn],res[maxn];
///b原始序列 置换满足结合律 求b^x  就是ans[];
void mul(int a[],int b[],int n) {///置换乘法
    for(int i=1;i<=n;++i) c[i]=b[a[i]];
    for(int i=1;i<=n;++i) a[i]=c[i];
}
void qpow(int n,int x) {
    for(int i=1;i<=n;++i) ans[i]=i;
    while(x) {
        if(x&1) mul(ans,b,n);
        mul(b,b,n);
        x>>=1;
    }
    for(int i=1;i<=n;++i) pos[ans[i]]=i; //答案原序列继续置换ans
    for(int i=1;i<=n;++i) c[pos[i]]=res[i];
    for(int i=1;i<=n;++i) res[i]=c[i];
}
```

### 拉格朗日插值

```C++
/*
ll f(int k){//给点n个点 构造函数确定n-1次多项式 暴力O(n^2)拉格朗日插值求f(k);
    ll ans=0;
    for(int i=1;i<=n;++i) {
        ll s1=y[i]%mod,s2=1;  //分子 分母
        for(int j=1;j<=n;++j)
            if(i!=j) s1=s1*(k-x[j])%mod,s2=s2*((x[i]-x[j]%mod+mod)%mod)%mod;
        ans+=s1*inv(s2)%mod;
        ans=(ans+mod)%mod;
    }
    return ans;
}
*/
ll pre[maxn],suf[maxn],fac[maxn];
ll f(int k) {//此处求前缀和i^k,实际上是k+1次多项式,不给定点值,选取连续的点,优化O(k log) 还可线性处理逆元
    pre[0]=suf[k+3]=fac[0]=1;
    for(int i=1;i<=k+2;++i) pre[i]=1ll*pre[i-1]*(n-i)%mod;
    for(int i=k+2;i>=1;--i) suf[i]=1ll*suf[i+1]*(n-i)%mod;
    for(int i=1;i<=k+2;++i) fac[i]=1ll*fac[i-1]*i%mod;
    ll ans=0;
    ll y=0;
    for(int i=1;i<=k+2;++i) {//k+1次多项式,需要k+2个点插值
        y=(y+quick(i,k))%mod;   //注意此处的yi是k+1次多项式,yi指的是前缀和,而不是原函数
        ll a=pre[i-1]*suf[i+1]%mod;
        ll b=fac[i-1]*((k+2-i)&1?-1ll:1ll)*fac[k+2-i]%mod; //分母fac注意奇偶性
        ans=(ans+y*a%mod*inv(b)%mod)%mod;
    }
    return (ans+mod)%mod;
}

///n个点,求得0~n-1的多项式系数  答案a[0]~a[n-1] x[1]~x[n],y
ll a[maxn], b[maxn], c[maxn], temp[maxn];
ll x[maxn],y[maxn];
int n;
void mul(ll *f, int len, ll t){//len为多项式的次数+1，函数让多项式f变成f*(x+t)
    for(int i = len; i > 0; --i) temp[i] = f[i], f[i] = f[i-1];
    temp[0] = f[0], f[0] = 0;
    for(int i = 0; i <= len; ++i) f[i]=(f[i] + t*temp[i])%mod;
}
void dev(ll *f, ll *r, ll t){//f是被除多项式的系数，r保存f除以x+t的结果
    for(int i = 0; i <= n; ++i) temp[i] = f[i];
    for(int i = n; i > 0; --i){
        r[i-1]=temp[i];
        temp[i-1]=(temp[i-1]-t*temp[i]%mod+mod)%mod;
    }
    return;
}
void lglr() {
    memset(temp,0,sizeof(temp));memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));memset(a,0,sizeof a);
    b[1] = 1, b[0] = -x[1];
    for(int i = 2; i <= n; ++i) mul(b, i, -x[i]);//预处理(x-x1)*(x-x2)...*(x-xn)
    for(int i = 1; i <= n; ++i){
        ll fz = 1;
        for(int j = 1; j <= n; ++j){
            if(j == i) continue;
            fz = fz*(x[i]-x[j]+mod)%mod;
        }
        fz = quick(fz, mod-2);
        fz = fz*y[i]%mod;//得到多项式系数
        dev(b, c, -x[i]);//得到多项式，保存在b数组
        for(int j = 0; j < n; ++j) a[j] = (a[j] + fz*c[j]%mod)%mod;
    }
}
```

### FFT NTT

```C++
//任意模数分治fft 拆系数优化 模数非质数也行
namespace Poly {
    const long double pi=acosl(-1);
    struct C {
        long double x,y;
        C():x(0),y(0){}
        C(long double a,long double b):x(a),y(b){}
        C operator+(const C &b){return C(x+b.x,y+b.y);}
        C operator-(const C &b){return C(x-b.x,y-b.y);}
        C operator*(const C &b){return C(x*b.x-y*b.y,x*b.y+y*b.x);}
        C operator/(long double b){return C(x/b,y/b);}
    };
    int id[N];
    int init(int n) {
        int ret=1;
        for(;1<<ret<n;ret++);
        for(int i=0;i<1<<ret;i++) id[i]=id[i>>1]>>1|((i&1)<<(ret-1));
        return 1<<ret;
    }
    C getwl(int x,int tag) {
        return C(cosl(2*pi/x),tag*sinl(2*pi/x));
    }
    void fft(C *a,int len,int tag=1) {
        for(int i=0;i<len;i++) if (id[i]>i) std::swap(a[i],a[id[i]]);
        for (int l=1;l<len;l<<=1) {
            C wl=getwl(l*2,tag);
            for (int st=0;st<len;st+=l<<1) {
                C w(1,0),tmp;
                for (int i=st;i<st+l;i++,w=w*wl) tmp=a[i+l]*w,a[i+l]=a[i]-tmp,a[i]=a[i]+tmp;
            }
        }
        if (tag<0) for (int i=0;i<len;i++) a[i]=a[i]/len;
    }
    int mul(int *ret,int *a,int alen,int *b,int blen,int M) {
        static C c[N],d[N],e[N];
        int s=alen+blen-1,len=init(s);
        for (int i=0;i<alen;i++) c[i]=C(a[i]>>15,a[i]&0x7fff);
		std::fill(c+alen,c+len,C());
        for (int i=0;i<blen;i++) d[i]=C(b[i]>>15,b[i]&0x7fff);
		std::fill(d+blen,d+len,C());
        fft(c,len),fft(d,len);
        for (int i=0;i<len;i++) {
            int j=(len-i)&(len-1);
            e[i]=d[i]*C(0.5*(c[i].x+c[j].x),0.5*(c[i].y-c[j].y));
            d[i]=d[i]*C(0.5*(c[i].y+c[j].y),0.5*(c[j].x-c[i].x));
        }
        fft(e,len,-1),fft(d,len,-1);
        for (int i=0;i<s;i++) {
            ll x=roundl(e[i].x),y=roundl(e[i].y),z=roundl(d[i].x),w=roundl(d[i].y);
            ret[i]=(((x%M<<30)%M+((y+z)%M<<15)%M+w%M)%M+M)%M;
        }
        return s;
    }
}
int a[N<<1],tot;
struct P{
	int *p,len;
	void init() {//根据具体情况设定系数和次幂,注意指针保证数组不重
	    int x;
	    reads(x);
	    int len=x+1;
	    p=a+tot;
		this->len=len;
		for(int i=0;i<len;++i) p[i]=0;
		p[0]++,p[len-1]++;
		tot+=len;
	}
	void mul(const P &b,int mod) {
		len=Poly::mul(p,p,len,b.p,b.len,mod);
	}
};
#define mid ((l+r)>>1)
P solve(int l,int r,int p) {
	P ret;
	if(l==r) ret.init();
	else {
		ret=solve(l,mid,p);
		ret.mul(solve(mid+1,r,p),p);
	}
	return ret;
}

namespace Polynomial {
using Poly = std::vector<int>;
constexpr int P(998244353), G(3);
inline void inc(int &x, int y) { (x += y) >= P ? x -= P : 0; }
inline int mod(int64_t x) { return x % P; }
inline int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k >>= 1, x = 1LL * x * x % P)
    if (k & 1) r = 1LL * r * x % P;
  return r;
}
template <int N>
std::array<int, N> getOmega() {
  std::array<int, N> w;
  for (int i = N >> 1, x = fpow(G, (P - 1) / N); i; i >>= 1, x = 1LL * x * x % P) {
    w[i] = 1;
    for (int j = 1; j < i; j++) w[i + j] = 1LL * w[i + j - 1] * x % P;
  }
  return w;
}
auto w = getOmega<1 << 20>();
Poly &operator*=(Poly &a, int b) { for (auto &x : a) x = 1LL * x * b % P; return a; }
Poly operator*(Poly a, int b) { return a *= b; }
Poly operator*(int a, Poly b) { return b * a; }
Poly &operator/=(Poly &a, int b) { return a *= fpow(b); }
Poly operator/(Poly a, int b) { return a /= b; }
Poly &operator+=(Poly &a, Poly b) {
  a.resize(std::max(a.size(), b.size()));
  for (int i = 0; i < b.size(); i++) inc(a[i], b[i]);
  return a;
}
Poly operator+(Poly a, Poly b) { return a += b; }
Poly &operator-=(Poly &a, Poly b) {
  a.resize(std::max(a.size(), b.size()));
  for (int i = 0; i < b.size(); i++) inc(a[i], P - b[i]);
  return a;
}
Poly operator-(Poly a, Poly b) { return a -= b; }
Poly operator-(Poly a) { for (auto &x : a) x ? x = P - x : 0; return a; }
Poly &operator>>=(Poly &a, int x) {
  if (x >= (int)a.size()) {
    a.clear();
  } else {
    a.erase(a.begin(), a.begin() + x);
  }
  return a;
}
Poly &operator<<=(Poly &a, int x) {
  a.insert(a.begin(), x, 0);
  return a;
}
Poly operator>>(Poly a, int x) { return a >>= x; }
Poly operator<<(Poly a, int x) { return a <<= x; }
inline Poly &dotEq(Poly &a, Poly b) {
  assert(a.size() == b.size());
  for (int i = 0; i < a.size(); i++) a[i] = 1LL * a[i] * b[i] % P;
  return a;
}
inline Poly dot(Poly a, Poly b) { return dotEq(a, b); }
void norm(Poly &a) {
  if (!a.empty()) {
    a.resize(1 << std::__lg(a.size() * 2 - 1));
  }
}
void dft(int *a, int n) {
  assert((n & n - 1) == 0);
  for (int k = n >> 1; k; k >>= 1) {
    for (int i = 0; i < n; i += k << 1) {
      for (int j = 0; j < k; j++) {
        int y = a[i + j + k];
        a[i + j + k] = 1LL * (a[i + j] - y + P) * w[k + j] % P;
        inc(a[i + j], y);
      }
    }
  }
}
void idft(int *a, int n) {
  assert((n & n - 1) == 0);
  for (int k = 1; k < n; k <<= 1) {
    for (int i = 0; i < n; i += k << 1) {
      for (int j = 0; j < k; j++) {
        int x = a[i + j], y = 1LL * a[i + j + k] * w[k + j] % P;
        a[i + j + k] = x - y < 0 ? x - y + P : x - y;
        inc(a[i + j], y);
      }
    }
  }
  for (int i = 0, inv = P - (P - 1) / n; i < n; i++) a[i] = 1LL * a[i] * inv % P;
  std::reverse(a + 1, a + n);
}
void dft(Poly &a) { dft(a.data(), a.size()); }
void idft(Poly &a) { idft(a.data(), a.size()); }
Poly operator*(Poly a, Poly b) {
  int len = a.size() + b.size() - 1;
  if (a.size() <= 8 || b.size() <= 8) {
    Poly c(len);
    for (size_t i = 0; i < a.size(); i++)
      for (size_t j = 0; j < b.size(); j++)
        c[i + j] = (c[i + j] + 1LL * a[i] * b[j]) % P;
    return c;
  }
  int n = 1 << std::__lg(len - 1) + 1;
  a.resize(n), b.resize(n);
  dft(a), dft(b);
  dotEq(a, b);
  idft(a);
  a.resize(len);
  return a;
}
Poly invRec(Poly a) {
  int n = a.size();
  assert((n & n - 1) == 0);
  if (n == 1) return {fpow(a[0])};
  int m = n >> 1;
  Poly b = invRec(Poly(a.begin(), a.begin() + m)), c = b;
  b.resize(n);
  dft(a), dft(b), dotEq(a, b), idft(a);
  for (int i = 0; i < m; i++) a[i] = 0;
  for (int i = m; i < n; i++) a[i] = P - a[i];
  dft(a), dotEq(a, b), idft(a);
  for (int i = 0; i < m; i++) a[i] = c[i];
  return a;
}
Poly inverse(Poly a) {
  int n = a.size();
  norm(a);
  a = invRec(a);
  a.resize(n);
  return a;
}
Poly operator/(Poly a, Poly b) {  // return: c(len = n - m + 1), a = b * c + r
  int n = a.size(), m = b.size();
  if (n < m) return {0};
  int k = 1 << std::__lg(n - m << 1 | 1);
  std::reverse(a.begin(), a.end());
  std::reverse(b.begin(), b.end());
  a.resize(k), b.resize(k), b = invRec(b);
  a = a * b;
  a.resize(n - m + 1);
  std::reverse(a.begin(), a.end());
  return a;
}
std::pair<Poly, Poly> operator%(Poly a, Poly b) {  // return: {c(len = n - m + 1), r(len = m - 1)}
  int m = b.size();
  Poly c = a / b;
  b = b * c;
  a.resize(m - 1);
  for (int i = 0; i < m - 1; i++) inc(a[i], P - b[i]);
  return {c, a};
}
Poly deriv(Poly a) {
  for (int i = 0; i + 1 < a.size(); i++) a[i] = (i + 1LL) * a[i + 1] % P;
  a.pop_back();
  return a;
}
std::vector<int> inv = {1, 1};
void updateInv(int n) {
  if ((int)inv.size() <= n) {
    int p = inv.size();
    inv.resize(n + 1);
    for (int i = p; i <= n; i++) inv[i] = 1LL * (P - P / i) * inv[P % i] % P;
  }
}
Poly integ(Poly a, int c = 0) {
  int n = a.size();
  updateInv(n);
  Poly b(n + 1);
  b[0] = c;
  for (int i = 0; i < n; i++) b[i + 1] = 1LL * inv[i + 1] * a[i] % P;
  return b;
}
Poly ln(Poly a) {
  int n = a.size();
  assert(a[0] == 1);
  a = inverse(a) * deriv(a);
  a.resize(n - 1);
  return integ(a);
}
// newton $O(n \log n)$
Poly expNewton(Poly a) {
  int n = a.size();
  assert((n & n - 1) == 0); assert(a[0] == 0);
  if (n == 1) return {1};
  int m = n >> 1;
  Poly b = expNewton(Poly(a.begin(), a.begin() + m)), c;
  b.resize(n), c = ln(b);
  a.resize(n << 1), b.resize(n << 1), c.resize(n << 1);
  dft(a), dft(b), dft(c);
  for (int i = 0; i < n << 1; i++) a[i] = (1LL + P + a[i] - c[i]) * b[i] % P;
  idft(a);
  a.resize(n);
  return a;
}
Poly power(Poly a, int k) {
  int n = a.size();
  long long d = 0;
  while (d < n && !a[d]) d++;
  if (d == n) return a;
  a >>= d;
  int b = fpow(a[0]);
  norm(a *= b);
  a = expNewton(ln(a) * k) * fpow(b, P - 1 - k % (P - 1));
  a.resize(n);
  d *= k;
  for (int i = n - 1; i >= d; i--) a[i] = a[i - d];
  d = std::min(d, 1LL * n);
  for (int i = d; i; a[--i] = 0) ;
  return a;
}
// Poly power(Poly a, int k1, int k2) // k1 = k % (P - 1), k2 = k % P, just replace {ln(a)*k with ln(a)*k2}

// [x^n](f / g)
// $O(m \log m \log n)$
int divAt(Poly f, Poly g, int64_t n) { 
  int len = std::max(f.size(), g.size()), m = 1 << std::__lg(len * 2 - 1);
  f.resize(len), g.resize(len);
  for (; n; n >>= 1) {
    f.resize(m * 2), g.resize(m * 2);
    dft(f), dft(g);
    for (int i = 0; i < m * 2; i++) f[i] = 1LL * f[i] * g[i ^ 1] % P;
    for (int i = 0; i < m; i++) g[i] = 1LL * g[i * 2] * g[i * 2 + 1] % P;
    g.resize(m);
    idft(f), idft(g);
    for (int i = 0, j = n & 1; i < len; i++, j += 2) f[i] = f[j];
    f.resize(len), g.resize(len);
  }
  return f[0];
}
}

namespace PolyEI {  // Polyial-MultiEvaluation & Interpolation-Polyial. 多点求值和快速插值
/*
To calc f(a_i): Construct SegTree with {a} and call multiEval(f).
To calc f from (a_i, b_i): Construct SegTree with {a} and call interpolate(b).
*/
using namespace Polynomial;
class SegTree {
  std::vector<Poly> p;
  int n, raw_n;
 public:
  SegTree(std::vector<int> a) {
    raw_n = a.size();
    n = 1 << std::__lg(2 * raw_n - 1);
    p.resize(n << 1);
    for (int i = 0; i < n; i++)
      p[i + n] = Poly({1, i < raw_n ? P - a[i] : 0});
    for (int i = n - 1; i; i--) {
      int ls = i << 1, rs = ls | 1, len = p[ls].size() - 1 << 1;
      p[ls].resize(len), p[rs].resize(len);
      dft(p[ls]), dft(p[rs]), p[i] = dot(p[ls], p[rs]), idft(p[i]);
      p[i].push_back((p[i][0] - 1 + P) % P);
      p[i][0] = 1;
    }
  }
  std::vector<int> multiEval(Poly f) const {
    int m = f.size();
    if (m == 1) return std::vector<int>(raw_n, f[0]);
    Poly q = inverse(p[1]);
    std::reverse(f.begin(), f.end());
    q = q * f;
    q.resize(m);
    if (m > n) {
      q = Poly(q.end() - n, q.end());
    } else {
      q.resize(n);
      std::rotate(q.begin(), q.begin() + m, q.end());  // xxx0000 -> 00000xxx
    }
    for (int k = n, o = 1; k > 1; k >>= 1)
      for (int i = 0; i < n; i += k, o++) {
        if (i >= raw_n) continue;
        int *a = &q[i];
        int const *l = p[o << 1].data(), *r = p[o << 1 | 1].data();
        dft(a, k);
        Poly foo(k), bar(k);
        for (int j = 0; j < k; j++) foo[j] = 1LL * a[j] * r[j] % P;
        for (int j = 0; j < k; j++) bar[j] = 1LL * a[j] * l[j] % P;
        idft(foo), idft(bar);
        std::copy(foo.end() - k / 2, foo.end(), a);
        std::copy(bar.end() - k / 2, bar.end(), a + k / 2);
      }
    q.resize(raw_n);
    return q;
  }
  Poly interpolate(std::vector<int> b) const {
    assert(b.size() == raw_n);
    Poly q(p[1].begin(), p[1].begin() + raw_n + 1);
    std::reverse(q.begin(), q.end());
    q = multiEval(deriv(q));
    for (int i = 0; i < raw_n; i++) q[i] = 1LL * fpow(q[i]) * b[i] % P;
    q.resize(n);
    for (int k = 1, h = n >> 1; k < n; k <<= 1, h >>= 1)
      for (int i = 0, o = h; i < n; i += k << 1, o++) {
        if (i >= raw_n) continue;
        int *a = &q[i], *b = &q[i + k];
        int const *l = p[o << 1].data(), *r = p[o << 1 | 1].data();
        Poly foo(k << 1), bar(k << 1);
        for (int j = 0; j < k; j++) foo[j] = a[j];
        for (int j = 0; j < k; j++) bar[j] = b[j];
        dft(foo), dft(bar);
        for (int j = 0; j < k << 1; j++)
          foo[j] = (1LL * foo[j] * r[j] + 1LL * bar[j] * l[j]) % P;
        idft(foo);
        std::copy(foo.begin(), foo.end(), a);
      }
    q.resize(raw_n);
    std::reverse(q.begin(), q.end());
    return q;
  }
};
}  // namespace PolyEI

//字符串匹配 s1模式串 求所有位置
void match_str(string s1,string s2,int m,int n) {
    reverse(s1.begin(),s1.end());
    for(int i=0;i<m;++i) a[i]=(s1[i]!='*')?(s1[i]-'a'+1):0;
    for(int i=0;i<n;++i) b[i]=(s2[i]!='*')?(s2[i]-'a'+1):0;
	int len = 1;
	for(; len <= n + m; len <<= 1);
	len_inv = quick(len, mod - 2);
	for(int i = 0; i <= len; i ++) rev[i] = (rev[i >> 1] >> 1) | ((i&1) * len >> 1);

    for(int i=0;i<len;++i) c1[i]=a[i]*a[i]*a[i],c2[i]=b[i];
    ntt(c1,len,1),ntt(c2,len,1);
    for(int i=0;i<len;++i) p[i]=(p[i]+c1[i]*c2[i]%mod)%mod;

    for(int i=0;i<len;++i) c1[i]=a[i],c2[i]=b[i]*b[i]*b[i];
    ntt(c1,len,1),ntt(c2,len,1);
    for(int i=0;i<len;++i) p[i]=(p[i]+c1[i]*c2[i]%mod)%mod;

    for(int i=0;i<len;++i) c1[i]=a[i]*a[i],c2[i]=b[i]*b[i];
    ntt(c1,len,1),ntt(c2,len,1);
    for(int i=0;i<len;++i) p[i]=(p[i]-2ll*c1[i]*c2[i]%mod+mod)%mod;
    ntt(p,len,-1);

    vector<int>ans;
    for(int i=m-1;i<n;++i) if(p[i]==0) ans.push_back(i-m+2);
    cout<<ans.size()<<'\n';
    for(auto &v:ans) cout<<v<<' ';
    cout<<'\n';
}
```

ntt模数 P=1004535809  g=3

构造卷积关系。

1.一段连续递增的数归到一个固定的下标，考虑卷上另一个数组就可以描述

2.固定差值对应的乘积，考虑反转另一个数组，得到卷积

### FWT

- $C_k=\sum_{i \oplus j=k} A_i B_j$

```C++
const int N=1<<18;//数最大 上界必须正好不能多不少
/// O(n*2^(n))
//模意义下
void fwt_or(int *a,int opt) {
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k)
                if(opt==1)a[i+j+k]=(a[j+k]+a[i+j+k])%mod;
                else a[i+j+k]=(a[i+j+k]+mod-a[j+k])%mod;
}
void fwt_and(int *a,int opt) {
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k)
                if(opt==1)a[j+k]=(a[j+k]+a[i+j+k])%mod;
                else a[j+k]=(a[j+k]+mod-a[i+j+k])%mod;
}
//inv2为2的逆元  inv2=mod/2+1;
void fwt_xor(int *a,int opt) {
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k) {
                int X=a[j+k],Y=a[i+j+k];
                a[j+k]=(X+Y)%mod;a[i+j+k]=(X+mod-Y)%mod;
                if(opt==-1)a[j+k]=1ll*a[j+k]*inv2%mod,a[i+j+k]=1ll*a[i+j+k]*inv2%mod;
            }
}

///F[x]=\sum_i A_i[x&i=i] subset of x  超集只需判定条件改成==0
for(int i=0;i<20;++i) for(int j=0;j<(1<<20);++j) if(j&(1<<i)) f[j]+=f[j^(1<<i)];
//多校题 任意多个子集的卷积 倍增处理?
```

## 矩阵

### 矩阵快速幂

```C++
const int v=2; //开维数
int d=2;//实际维数
struct matrix {
    ll m[v][v];
    void init() {memset(m,0,sizeof(m));for(int i=0;i<d;++i) m[i][i]=1;}
    void clear() {memset(m,0,sizeof(m));}
    matrix operator +(const matrix &o) const {
        matrix res={};
        for(int i=0;i<d;++i)
            for(int j=0;j<d;++j)
                res.m[i][j]=(m[i][j]+o.m[i][j])%mod;
        return res;
    }
    matrix operator *(const matrix &o) const {//优化常数展开此矩阵
        matrix res={};
        for(int i=0;i<d;i++)
            for(int j=0;j<d;j++)
                for(int k=0;k<d;k++)
                    res.m[i][j]=(res.m[i][j]+m[i][k]*o.m[k][j]%mod)%mod;
        return res;
    }
    matrix operator -(const matrix &o) const {
        matrix res={};
        for(int i=0;i<d;++i)
            for(int j=0;j<d;++j)
                res.m[i][j]=(m[i][j]-o.m[i][j]+mod)%mod;
        return res;
    }
}Ans,base;
inline void mat_quick(ll p) {
    Ans.init();
    base={1,1,1,0};
    while(p) {
        if(p&1) Ans=Ans*base;
        base=base*base;
        p>>=1;
    }
}
```

### 高斯消元求解线性方程组

```c++
///很多姿势 消成主对角线 直接求解
///消成上三角 倒着带入求解  此种方便优化 
///解的个数参加bitset版
void gauss(int n) { //a[0~n-1][0~n] 最后一列为解 
    for(int j=0;j<n;++j) {
        int pivot=j;
        for(int i=j+1;i<n;++i) if(fabs(a[i][j])>fabs(a[pivot][j])) pivot=i;
        if(pivot!=j) swap(a[j],a[pivot]);
        if(fabs(a[j][j])<eps) {
            puts("Arbitrary Solution");   //全为1 自由元
            return;
        }
        for(int i=0;i<n;++i) { //每一行进行消元
            if(i!=j) {
                db tmp=a[i][j]/a[j][j];
                for(int k=j+1;k<=n;++k) a[i][k]-=a[j][k]*tmp;
            }
        }
    }
//    上述操作结束后，矩阵会变成这样
//    k1*a=e1
//    k2*b=e2
    for(int i=0;i<n;++i) printf("%.2f\n",a[i][n+1]/a[i][i]);
}
///取模版本
typedef vector<int> vi;
int a[maxn][maxn];
vi gauss_jordan(int n) {
    for(int i=0;i<n;i++) {
        int pivot=i;
        for(int j=i;j<n;j++) {
            if(a[j][i]) {
                pivot=j;
                break;
            }
        }
        if(pivot!=i) swap(a[i],a[pivot]);
        if(!a[i][i]) break;
        ll ib=quick(a[i][i],mod-2);
        for(int j=i+1;j<=n;j++) a[i][j]=1ll*a[i][j]*ib%mod;
        for(int j=i+1;j<n;j++) if(i!=j && a[j][i]) for(int k=n;k>=i+1;--k) a[j][k]=(a[j][k]-1ll*a[i][k]*a[j][i]%mod+mod)%mod;
    }
    vi x(n);///消成上三角 主对角线为1
    for(int j=n-1;j>=0;--j) { //回代得到解
        x[j]=a[j][n];
        for(int i=j-1;i>=0;--i) a[i][n]=(a[i][n]-1ll*a[i][j]*x[j]%mod+mod)%mod;
    }
    return x;
}
```

### 基尔霍夫矩阵(矩阵行列式求值)

无向图生成树计数

```C++
ll a[N][N];
ll determinant(int n){
	ll ans=1,mul,inv;
	for(int i=1;i<=n;++i){
        if(!a[i][i]) {
            for(int j=i+1;j<=n;++j) {
                if(a[j][i]) {
                    swap(a[i],a[j]);ans=mod-ans;
                    break;
                }
            }
        }
	    if(!a[i][i]) return 0;
	    inv=quick(a[i][i]),ans=ans*a[i][i]%mod;
	    for(int j=i+1;j<=n;++j){
			mul=inv*a[j][i]%mod;
	        for(int k=i;k<=n;++k) a[j][k]=(a[j][k]-mul*a[i][k]%mod+mod)%mod;
	    }
	}
	return ans;
}
```

main:维护度数，求n-1阶矩阵的行列式即可

```C++
D-E 对角线度数矩阵减去邻接边数矩阵
```

### 矩阵求逆

```C++
void gauss() {
    for(int j=1;j<=n;++j) {//枚举列 其实也是行
        int mx=j;
        for(int i=j+1;i<=n;++i) if(abs(a[i][j])>abs(a[mx][j])) mx=i;
        if(mx!=j) swap(a[mx],a[j]);
        if(!a[j][j]) {
            puts("No Solution");   //全为1 自由元
            return;
        }
        ll inv=quick(a[j][j],mod-2);
        for(int i=1;i<=n;++i) {  //每一行进行消元
            if(i!=j) {
                ll tmp=a[i][j]*inv%mod;
                for(int k=j;k<=n*2;++k) {//前面全消掉了为0
                    a[i][k]=(a[i][k]-a[j][k]*tmp%mod+mod)%mod;
                }
            }
        }
        for(int i=1;i<=2*n;++i) a[j][i]=a[j][i]*inv%mod;
    }
    for(int i=1;i<=n;++i)
        for(int j=n+1;j<=2*n;++j)
            printf("%lld%c",a[i][j],j==2*n?'\n':' ');
}
```

### bitset优化解异或方程组

```C++
bitset<207>a[207];
int gauss(int n) {///the number of free solution.
    int tmp=0;
    for (int i = 1, row = 1; i <= n; ++i, ++row) {
        int ma = -1;
        for (int j = row; j <= n; ++j) {
            if (a[j][i]) {
                ma = j;
                break ;
            }
        }
        if (ma == -1) {///尤其注意此处不能正常下一行
            --row;
            tmp++;
            continue ;
        }
        if (ma != row)    swap(a[row], a[ma]);
        for (int j = row + 1; j <= n; ++j)
            if (a[j][i])    a[j] ^= a[row];
    }
    return tmp;
}
///判断是否存在解
int n,k;
bitset<N>s[N];
bool check(int x) {///消元后 如果还有约束 只有一个 有变量直接对 不是异或方程组也是类似
    for(int i=1;i<n; i++) if(a[x][i])return true;
    return !a[x][n];
}
bool gauss() {///判断是否线性方程组有解  k行 n列, 第n列是解 实际k*n-1
    for(int i=1;i<=k;i++) if(!check(i)) return false;
    return true;
}
```

## 杂项

### 拆分数五边形数

```c++
    dp[0]=1;
    int mx=100000;
    for(int i=1;i<=mx;++i) {
        for(int j=1,tmp=1;(3*j*j-j)/2<=i;++j,tmp*=-1) {
            int x=(3*j*j-j)/2;
            int y=(3*j*j+j)/2;
            dp[i]=(dp[i]+tmp*dp[i-x]%mod+mod)%mod;
            if(i>=y) dp[i]=(dp[i]+tmp*dp[i-y]%mod+mod)%mod;
        }
    }
    int q,n,k;
    cin>>q;
    while(q--) {
        cin>>n>>k;
        ll ans=dp[n];//询问每个数出现次数<k的拆分数
        for(int j=1,tmp=-1;(3*j*j-j)/2*k<=n;++j,tmp*=-1) {
            int x=(3*j*j-j)/2*k;
            int y=(3*j*j+j)/2*k;
            ans=(ans+tmp*dp[n-x]%mod+mod)%mod;
            if(n>=y) ans=(ans+tmp*dp[n-y]%mod+mod)%mod;
        }
        cout<<ans<<'\n';
    }
```

### 线性基

```C++
//线性基板子 若提取区间信息，可以维护前缀线性基，使得某个位置的基相对于每个右端点尽可能右
//求n维向量极大线性无关组，可以维护若干个bitset或者vector即可
struct Linebasis{
    ll p[65], b[65];
    int cnt; //秩
    bool flag; //是否极大线性无关组
    void init(){
        memset(p, 0, sizeof(p));memset(b, 0, sizeof(b));
        cnt=0;
        flag=false;
    }
    bool insert(ll x){
        for(int i = 62; i >= 0; i--){
            if((x >> i) & 1){
                if(!p[i]){
                    p[i] = x;
                    break;
                }
                x ^= p[i];
            }
        }
        if(x) cnt++;
        else flag = true;
        return x > 0;
    }
    bool check(ll x) { //注意特判x=0 空集是否真的合法
        for(int i=62;i>=0;--i) if((x^p[i])<x) x^=p[i];
        return x==0;
    }
    Linebasis operator +(const Linebasis & r) const{
        Linebasis res = r;
        for(int i = 0; i <= 62; i++) {
            if(p[i])
                res.insert(p[i]);
        }
        return res;
    }
    ll querymax(ll x=0){
        ll res=x;
        for(int i=62;i>=0;--i) if((res ^ p[i]) > res) res ^= p[i];
        return res;
    }
    void rebuild(){
        for(int i = 62; i >= 0; i--){
            for(int j = i - 1; j >= 0; j--){
                if((p[i] >> j) & 1) p[i] ^= p[j];
            }
        }
        cnt = 0;
        for(int i = 0; i <= 62; i++){
            if(p[i]) b[cnt++] = p[i];
        }
    }
    ll kthmax(ll k){
        if(flag) k--;
        ll res = 0;
        if(!k) return 0;
        if(k >= (1ll << cnt)) return -1;
        for(int i = 62; i >= 0; i--){
            if((k >> i) & 1) res ^= b[i];
        }
        return res;
    }
}sol;
```

### 高级筛法(仅模板)素数前缀和杜教

```c++
///素数前缀和
const int N = sqrt(1e11) * 2 + 10;
bool isprime[N];
int prime[N / 10], pcnt;
ll sump[N / 10],n;
void Linear_Sieve(int maxn) {
	for(int i=0;i<=maxn;++i) isprime[i]=1;
	isprime[0] = isprime[1] = false;
	for(int i=2;i<=maxn;++i) {
		if(isprime[i])
		{
			prime[++ pcnt] = i;
			sump[pcnt] = sump[pcnt - 1] + i;
		}
		for(int j = 1; j <= pcnt && 1ll*prime[j]*i<=maxn;++j) {
			isprime[prime[j] * i] = false;
            if(!(i % prime[j])) break;
		}
	}
}
int d, id1[N], id2[N];
ll val[N], res[N];
#define id(x) (x <= d ? id1[x] : id2[n / (x)])
inline ll Sum(ll n) {
	return n * (n + 1) / 2 - 1;
}
ll Min25_Sieve(ll n) {
	int cnt = 0; d = sqrt((long long)(n));
	for (ll i = 1; i <= n; i = n / (n / i) + 1)
		val[id(n / i) = ++ cnt] = n / i, res[cnt] = Sum(n / i);

	for(int i=1;i<=pcnt;++i)
		for(int j = 1; j <= cnt && 1ll * prime[i] * prime[i] <= val[j]; ++ j)
			res[j] -= (res[id(val[j] / prime[i])] - sump[i - 1]) * prime[i];
	return res[id(n)];
}
int main () {
	scanf("%lld",&n);
	Linear_Sieve(sqrt(n + 0.5));
	printf("%lld\n",Min25_Sieve(n));
	return 0;
}
///前缀素数个数
typedef long long ll;
const int N = 5e6+2;
bool np[N];
int prime[N], pi[N];
int getprime() {
    int cnt = 0;
    np[0] = np[1] = true;
    pi[0] = pi[1] = 0;
    for(int i = 2; i < N; ++i) {
        if(!np[i]) prime[++cnt] = i;
        pi[i] = cnt;
        for(int j = 1; j <= cnt && i * prime[j] < N; ++j) {
            np[i * prime[j]] = true;
            if(i % prime[j] == 0)   break;
        }
    }
    return cnt;
}
const int M = 2;//为了减小内存可以不过是质数
const int PM = 2 * 3 * 5 ;//为了减小内存可以不过要按质数减小如去掉17
int phi[PM + 1][M + 1], sz[M + 1];

void init() {
    getprime();
    sz[0] = 1;
    for(int i = 0; i <= PM; ++i)  phi[i][0] = i;
    for(int i = 1; i <= M; ++i) {
        sz[i] = prime[i] * sz[i - 1];
        for(int j = 1; j <= PM; ++j) phi[j][i] = phi[j][i - 1] - phi[j / prime[i]][i - 1];
    }
}
int sqrt2(ll x) {
    ll r = (ll)sqrt(x - 0.1);
    while(r * r <= x)   ++r;
    return int(r - 1);
}
int sqrt3(ll x) {
    ll r = (ll)cbrt(x - 0.1);
    while(r * r * r <= x)   ++r;
    return int(r - 1);
}
ll getphi(ll x, int s) {
    if(s == 0)  return x;
    if(s <= M)  return phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];
    if(x <= prime[s]*prime[s])   return pi[x] - s + 1;
    if(x <= prime[s]*prime[s]*prime[s] && x < N) {
        int s2x = pi[sqrt2(x)];
        ll ans = pi[x] - (s2x + s - 2) * (s2x - s + 1) / 2;
        for(int i = s + 1; i <= s2x; ++i) ans += pi[x / prime[i]];
        return ans;
    }
    return getphi(x, s - 1) - getphi(x / prime[s], s - 1);
}
ll getpi(ll x) {
    if(x < N)   return pi[x];
    ll ans = getphi(x, pi[sqrt3(x)]) + pi[sqrt3(x)] - 1;
    for(int i = pi[sqrt3(x)] + 1, ed = pi[sqrt2(x)]; i <= ed; ++i) ans -= getpi(x / prime[i]) - i + 1;
    return ans;
}
ll lehmer_pi(ll x) {//小于等于n的素数有多少个O(n^(2/3))
    if(x < N)   return pi[x];
    int a = (int)lehmer_pi(sqrt2(sqrt2(x)));
    int b = (int)lehmer_pi(sqrt2(x));
    int c = (int)lehmer_pi(sqrt3(x));
    ll sum = getphi(x, a) +(ll)(b + a - 2) * (b - a + 1) / 2;
    for (int i = a + 1; i <= b; i++) {
        ll w = x / prime[i];
        sum -= lehmer_pi(w);
        if (i > c) continue;
        ll lim = lehmer_pi(sqrt2(w));
        for (int j = i; j <= lim; j++) sum -= lehmer_pi(w / prime[j]) - (j - 1);
    }
    return sum;
}

///杜教筛
ll smu[maxn],sphi[maxn];
int prime[maxn/5];
bool notprime[maxn];
int cnt;
unordered_map<int,ll>Smu,Sphi;  //里面不开ll 过不了 极限数据1 2147483647
//1401784457568941916 9569
void init() ///get mu phi presum
ll getsummu(int n) {
    if(n<maxn) return smu[n];
    if(Smu[n]) return Smu[n];
    ll res=1ll;
    for(ll l=2,r;l<=n;l=r+1) {
        r=n/(n/l);
        res-=(r-l+1)*getsummu(n/l);
    }
    return Smu[n]=res;
}
ll getsumphi(int n) {
    if(n<maxn) return sphi[n];
    if(Sphi[n]) return Sphi[n];
    ll res=(n+1ll)*n/2ll;
    for(ll l=2,r;l<=n;l=r+1) {
        r=n/(n/l);
        res-=(r-l+1)*getsumphi(n/l);
    }
    return Sphi[n]=res;
}
```

### BM

bm最短线性递推式(丢前若干项进去)

要求:

1. 线性递推
2. 所有数都有逆元
3. k阶线性递推需要 2k 项

```C++
#define vi vector<int>
const int mod=998244353;
vi mult_mod_f(const vi&x,const vi&y,const vi&f) {
    int n=x.size(),m=y.size();
    vi res(n+m-1);
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            res[i+j]=(res[i+j]+(ll)x[i]*y[j]%mod)%mod;
    int k=f.size();
    for(int i=n+m-2;i>=k-1;i--) {
        int w=(ll)res[i]*inv(f[k-1])%mod;
        for(int p=0;p<k-1;p++)
            res[i-(k-1)+p]=(res[i-(k-1)+p]-(ll)w*f[p]%mod+mod)%mod;
    }
    res.resize(k-1);
    return res;
}
vi getf(const vi& p) {
    int sz=p.size();
    vi f(sz+1);
    f[sz]=1;
    for(int i=0;i<sz;i++) f[sz-1-i]=mod-p[i];
    return f;
}
vi getweight(const vi&f,ll q) {
    int n=f.size();
    vi x(n);
    x[0]=1;
    vi z{0,1};
    while(q) {
        if(q&1) x=mult_mod_f(x,z,f);
        z=mult_mod_f(z,z,f);
        q>>=1;
    }
    return x;
}
vi BM(const vi& s) {
    vi C(1,1),B(1,1);
    int L=0,m=1,b=1;
    for(int n=0;n<s.size();n++) {
        ll d=0;
        for(int i=0;i<L+1;i++)
            d=(d+(ll)C[i]*s[n-i])%mod;
        if (d==0) ++m;
        else if (2*L<=n) {
            vi T=C;
            ll c=mod-d*quick(b,mod-2)%mod;
            while (C.size()<B.size()+m) C.push_back(0);
            for(int i=0;i<B.size();i++)
                C[i+m]=(C[i+m]+c*B[i])%mod;
            L=n+1-L; B=T; b=d; m=1;
        } else {
            ll c=mod-d*inv(b)%mod;
            while (C.size()<B.size()+m) C.push_back(0);
            for(int i=0;i<B.size();i++)
                C[i+m]=(C[i+m]+c*B[i])%mod;
            ++m;
        }
    }
    C.erase(C.begin());
    for(int i=0;i<C.size();i++) C[i]=(mod-C[i])%mod;
    return C;
}
int gao(const vi&a,ll n) {
    vi c=BM(a);//求解递推 O(a^2)
    vi f=getf(c);//构造f
    vi s=getweight(f,n);//求解系数 O(c^2logn)
    ll ret=0;
    for(int i=0;i<s.size();i++) ret=(ret+(ll)s[i]*a[i]%mod)%mod;
    return ret;
}
```

### tips

- 组合数、卡特兰数模数不是质数，考虑质因数分解.
- 至多至少的转化容斥，min-max容斥.
- $a_i + a_j-a_i \or a_j=a_i \& a_j$​

---

### 一些数论公式

- 当 $x\geq\phi(p)$ 时有 $a^x\equiv a^{x ; mod ; \phi(p) + \phi(p)}\pmod p$
- $\mu^2(n)=\sum_{d^2|n} \mu(d)$
- $\sum_{d|n} \varphi(d)=n$
- $\sum_{d|n} 2^{\omega(d)}=\sigma(n^2)$， $\omega$是不同素因子个数，$\sigma$因数个数
- $\sum_{d|n} \mu^2(d)=2^{\omega(n)}$
- 单位根反演 $[n|i]=\frac 1{n}\sum _{j=0} ^{n-1}\omega_k^{j*i}$ , 一般用原根 $\omega = g^{\frac{p-1}{n}}$。
- $ax \equiv k\mod {M}  \iff x \equiv \frac{k}{\gcd(M,a)}\mod \frac{M}{\gcd(M,a)}$，$k$是gcd的倍数
- $\frac{x}{b}$是整数且，$\frac{x}{b}\equiv k\mod {M}  \iff x \equiv kb \mod bM  $

### 一些数论函数求和的例子

- $\sum_{i=1}^n i[gcd(i, n)=1] = \frac {n \varphi(n) + [n=1]}{2}$
- $\sum_{i=1}^n \sum_{j=1}^m [gcd(i,j)=x]=\sum_d \mu(d) \lfloor \frac n {dx} \rfloor \lfloor \frac m {dx} \rfloor$
- $\sum_{i=1}^n \sum_{j=1}^m gcd(i, j) = \sum_{i=1}^n \sum_{j=1}^m \sum_{d|gcd(i,j)} \varphi(d) = \sum_{d} \varphi(d) \lfloor \frac nd \rfloor \lfloor \frac md \rfloor$
- $S(n)=\sum_{i=1}^n \mu(i)=1-\sum_{i=1}^n \sum_{d|i,d < i}\mu(d) \overset{t=\frac id}{=} 1-\sum_{t=2}^nS(\lfloor \frac nt \rfloor)$
  - 利用 $[n=1] = \sum_{d|n} \mu(d)$
- $S(n)=\sum_{i=1}^n \varphi(i)=\sum_{i=1}^n i-\sum_{i=1}^n \sum_{d|i,d<i} \varphi(i)\overset{t=\frac id}{=} \frac {i(i+1)}{2} - \sum_{t=2}^n S(\frac n t)$
  - 利用 $n = \sum_{d|n} \varphi(d)$
- $\sum_{i=1}^n \mu^2(i) = \sum_{i=1}^n \sum_{d^2|n} \mu(d)=\sum_{d=1}^{\lfloor \sqrt n \rfloor}\mu(d) \lfloor \frac n {d^2} \rfloor$
- $\sum_{i=1}^n \sum_{j=1}^n gcd^2(i, j)= \sum_{d} d^2 \sum_{t} \mu(t) \lfloor \frac n{dt} \rfloor ^2 \ \overset{x=dt}{=} \sum_{x} \lfloor \frac nx \rfloor ^ 2 \sum_{d|x} d^2 \mu(\frac xd)$
- $\sum_{i=1}^n \varphi(i)=\frac 12 \sum_{i=1}^n \sum_{j=1}^n [i \perp j] - 1=\frac 12 \sum_{i=1}^n \mu(i) \cdot\lfloor \frac n i \rfloor ^2-1$

### 斐波那契数列性质

- $F_{a+b}=F_{a-1} \cdot F_b+F_a \cdot F_{b+1}$
- $F_1+F_3+\dots +F_{2n-1} = F_{2n},F_2 + F_4 + \dots + F_{2n} = F_{2n + 1} - 1$
- $\sum_{i=1}^n F_i = F_{n+2} - 1$
- $\sum_{i=1}^n F_i^2 = F_n \cdot F_{n+1}$
- $F_n^2=(-1)^{n-1} + F_{n-1} \cdot F_{n+1}$
- $gcd(F_a, F_b)=F_{gcd(a, b)}$
- 模 $n$ 周期（皮萨诺周期）
  - $\pi(p^k) = p^{k-1} \pi(p)$
  - $\pi(nm) = lcm(\pi(n), \pi(m)), \forall n \perp m$
  - $\pi(2)=3, \pi(5)=20$
  - $\forall p \equiv \pm 1\pmod {10}, \pi(p)|p-1$
  - $\forall p \equiv \pm 2\pmod {5}, \pi(p)|2p+2$

### 常见生成函数

- $(1+ax)^n=\sum_{k=0}^n \binom {n}{k} a^kx^k$
- $\dfrac{1-x^{r+1}}{1-x}=\sum_{k=0}^nx^k$
- $\dfrac1{1-ax}=\sum_{k=0}^{\infty}a^kx^k$
- $\dfrac 1{(1-x)^2}=\sum_{k=0}^{\infty}(k+1)x^k$
- $\dfrac1{(1-x)^n}=\sum_{k=0}^{\infty} \binom{n+k-1}{k}x^k$
- $e^x=\sum_{k=0}^{\infty}\dfrac{x^k}{k!}$
- $\ln(1+x)=\sum_{k=1}^{\infty}\dfrac{(-1)^{k-1}}{k}x^k$

### 佩尔方程

若一个丢番图方程具有以下的形式：$x^2 - ny^2= 1$。且 $n$ 为正整数，则称此二元二次不定方程为**佩尔方程**。

若 $n$ 是完全平方数，则这个方程式只有平凡解 $(\pm 1,0)$（实际上对任意的 $n$，$(\pm 1,0)$ 都是解）。对于其余情况，拉格朗日证明了佩尔方程总有非平凡解。而这些解可由 $\sqrt{n}$ 的连分数求出。

$x = [a_0; a_1, a_2, a_3]=x = a_0 + \cfrac{1}{a_1 + \cfrac{1}{a_2 + \cfrac{1}{a_3 + \cfrac{1}{\ddots,}}}}$

设 $\tfrac{p_i}{q_i}$ 是 $\sqrt{n}$ 的连分数表示：$[a_{0}; a_{1}, a_{2}, a_{3}, ,\ldots ]$ 的渐近分数列，由连分数理论知存在 $i$ 使得 $(p_i,q_i)$ 为佩尔方程的解。取其中最小的 $i$，将对应的 $(p_i,q_i)$ 称为佩尔方程的基本解，或最小解，记作 $(x_1,y_1)$，则所有的解 $(x_i,y_i)$ 可表示成如下形式：$x_{i}+y_{i}{\sqrt n}=(x_{1}+y_{1}{\sqrt n})^{i}$。或者由以下的递回关系式得到：

$\displaystyle x_{i+1} = x_1 x_i + n y_1 y_i$, $\displaystyle y_{{i+1}}=x_{1}y_{i}+y_{1}x_{i}$。

**但是：**佩尔方程千万不要去推（虽然推起来很有趣，但结果不一定好看，会是两个式子）。记住佩尔方程结果的形式通常是 $a_n=ka_{n−1}−a_{n−2}$（$a_{n−2}$ 前的系数通常是 $−1$）。暴力 / 凑出两个基础解之后加上一个 $0$，容易解出 $k$ 并验证。

### Burnside & Polya

- $|X/G|={\frac {1}{|G|}}\sum _{{g\in G}}|X^{g}|$

注：$X^g$ 是 $g$ 下的不动点数量，也就是说有多少种东西用 $g$ 作用之后可以保持不变。

- $|Y^X/G| = \frac{1}{|G|}\sum_{g \in G} m^{c(g)}$

注：用 $m$ 种颜色染色，然后对于某一种置换 $g$，有 $c(g)$ 个置换环，为了保证置换后颜色仍然相同，每个置换环必须染成同色。

### 皮克定理

$2S = 2a+b-2$

- $S$ 多边形面积
- $a$ 多边形内部点数
- $b$ 多边形边上点数

### 莫比乌斯反演

- $g(n) = \sum_{d|n} f(d) \Leftrightarrow f(n) = \sum_{d|n} \mu (d) g( \frac{n}{d})$
- $f(n)=\sum_{n|d}g(d) \Leftrightarrow g(n)=\sum_{n|d} \mu(\frac{d}{n}) f(d)$

### 低阶等幂求和

- $\sum_{i=1}^{n} i^{1} = \frac{n(n+1)}{2} = \frac{1}{2}n^2 +\frac{1}{2} n$
- $\sum_{i=1}^{n} i^{2} = \frac{n(n+1)(2n+1)}{6} = \frac{1}{3}n^3 + \frac{1}{2}n^2 + \frac{1}{6}n$
- $\sum_{i=1}^{n} i^{3} = \left[\frac{n(n+1)}{2}\right]^{2} = \frac{1}{4}n^4 + \frac{1}{2}n^3 + \frac{1}{4}n^2$
- $\sum_{i=1}^{n} i^{4} = \frac{n(n+1)(2n+1)(3n^2+3n-1)}{30} = \frac{1}{5}n^5 + \frac{1}{2}n^4 + \frac{1}{3}n^3 - \frac{1}{30}n$
- $\sum_{i=1}^{n} i^{5} = \frac{n^{2}(n+1)^{2}(2n^2+2n-1)}{12} = \frac{1}{6}n^6 + \frac{1}{2}n^5 + \frac{5}{12}n^4 - \frac{1}{12}n^2$

### 一些组合公式

- 错排公式：$D_1=0,D_2=1,D_n=(n-1)(D_{n-1} + D_{n-2})=n!(\frac 1{2!}-\frac 1{3!}+\dots + (-1)^n\frac 1{n!})=\lfloor \frac{n!}e + 0.5 \rfloor$
- 卡塔兰数（$n$ 对括号合法方案数，$n$ 个结点二叉树个数，$n\times n$ 方格中对角线下方的单调路径数，凸 $n+2$ 边形的三角形划分数，$n$ 个元素的合法出栈序列数）：$C_n=\frac 1{n+1}\binom {2n}n=\frac{(2n)!}{(n+1)!n!}$

### 拉格朗日反演式子
找到 $G(x)$，使得 $G(F(x))=x$，有 $[x^n]F(x)=\frac {1}{n} [x^{n-1}] (\frac{x}{G(x)})^n$.

比如要求第 $[x^n]F(x)$, $F(x)=x(1+3F(x)+F(x)^2)^2$ ,构造

$G(x)=\frac{x}{(1+3x+x^2)^2}$，可得$[x^n]F(x)=\frac {1}{n} [x^{n-1}] (1+3x+x^2)^{2n}$

只需求后面，可以用二项展开

### 黎曼函数伯努利数

求 $\zeta (s)=\sum _{n=1}^{\infty }{\frac {1}{n^{s} }}$ 的 $s$ 为偶数情况下的某项系数。

保证 $\zeta (s)=\sum _{n=1}^{\infty }{\frac {p_n}{q_n} \pi ^s}$ 。

有结论：$\zeta(2n)=\frac{(2\pi)^{2n}(-1)^{n+1}B_{2n}}{2\cdot(2n)!}$ 

而利用 $bernoulli$ 数的指数型母函数， $ G_e(x)= \sum _{n=1}^{\infty } \frac{B_i}{i!}x^i = \frac {1} {\sum _{n=0}^{\infty }\frac{x^i}{(i+1)!}} $，该系数可以通过多项式求逆得到。

再可转化得到伯努利数，带入原式得到答案。

应用：

$S(n,k)=\sum_{i=0}^{n}i^k$

那么令 $B_i$ 表示伯努利数列的第 i 项，则有：

$S(n,k)=\frac{1}{k+1}\sum_{i=0}^kC(k+1,i)B_i*n^{k+1−i}$

